#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass amsart
\begin_preamble

%
\usepackage{amsfonts}
\usepackage{mathabx}
\usepackage{nopageno}%%%  The following few lines affect the margin sizes. 
\usepackage{bm}
\addtolength{\topmargin}{-.5in}
\setlength{\textwidth}{6in}       
\setlength{\oddsidemargin}{.25in}              
\setlength{\evensidemargin}{.25in}         
  
\setlength{\textheight}{9in}
\renewcommand{\baselinestretch}{1}
\reversemarginpar   
%
%
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 2
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Notes
\end_layout

\begin_layout Author
Maksim Levental
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Definition*
For functions 
\begin_inset Formula $f,g$
\end_inset

 if there exist 
\begin_inset Formula $c,N\in\mathbb{N}$
\end_inset

 such that for every 
\begin_inset Formula $n\geq N$
\end_inset

 
\begin_inset Formula 
\[
f\left(n\right)\leq cg\left(n\right)
\]

\end_inset

then 
\begin_inset Formula $f\in O\left(g\left(n\right)\right)$
\end_inset

 or 
\begin_inset Formula $f=O\left(g\left(n\right)\right)$
\end_inset

.
 Alternatively if 
\begin_inset Formula 
\[
\lim_{n\rightarrow\infty}\frac{f\left(n\right)}{g\left(n\right)}<\infty
\]

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition*
For functions 
\begin_inset Formula $f,g$
\end_inset

 if for all 
\begin_inset Formula $c>0$
\end_inset

 there exist 
\begin_inset Formula $N\in\mathbb{N}$
\end_inset

 such that for every 
\begin_inset Formula $n\geq N$
\end_inset

 
\begin_inset Formula 
\[
f\left(n\right)<cg\left(n\right)
\]

\end_inset

then 
\begin_inset Formula $f\in o\left(g\left(n\right)\right)$
\end_inset

 or 
\begin_inset Formula $f=o\left(g\left(n\right)\right)$
\end_inset

.
 Alternatively if 
\begin_inset Formula 
\[
\lim_{n\rightarrow\infty}\frac{f\left(n\right)}{g\left(n\right)}=0
\]

\end_inset


\end_layout

\begin_layout Standard
We can count the number of 
\begin_inset Quotes eld
\end_inset

steps
\begin_inset Quotes erd
\end_inset

 a TM takes to decide a language.
 This suggests the notion of time complexity classes:
\end_layout

\begin_layout Definition*
Let 
\begin_inset Formula $t:\mathbb{N}\rightarrow\mathbb{N}$
\end_inset

.
 Then the time complexity class
\begin_inset Formula 
\[
\text{TIME}\left(t\left(n\right)\right)\coloneqq\left\{ L\big|L\text{ is a language decided by a }O\left(t\left(n\right)\right)\text{ time Turing machine}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $\text{TIME}\left(t\left(n\right)\right)$
\end_inset

 is a class of languages, i.e.
 class of sets.
 This definition of running time for a nondeterministic TM has to be defined
 differently since an NTM just guesses the right path:
\end_layout

\begin_layout Definition*
Let 
\begin_inset Formula $N$
\end_inset

 be a nondeterministic TM that always halts.
 Then the running time 
\begin_inset Formula $f\left(n\right)$
\end_inset

 of 
\begin_inset Formula $N$
\end_inset

 is the maximum number of steps that 
\begin_inset Formula $N$
\end_inset

 uses on any branch of its computation on any input of length 
\begin_inset Formula $n$
\end_inset

.
 If you think of a nondeterministic TM as a computational tree that guesses
 the right computation path (or tries all computational pathes simultaneously)
 then the running time of the NTM is the longest path (even if it rejects).
\end_layout

\begin_layout Theorem*
\begin_inset Formula $\text{NTIME}\left(t\left(n\right)\right)\subset\text{DTIME}\left(2^{O\left(t\left(n\right)\right)}\right)$
\end_inset


\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $N$
\end_inset

 be an NTM with running time 
\begin_inset Formula $t\left(n\right)$
\end_inset

.
 By equivalence of TMs we can construct a deterministic TM that decides
 the same langauge as 
\begin_inset Formula $N$
\end_inset

.
 Consider the constrution: on any input of length 
\begin_inset Formula $n$
\end_inset

 the computation path in 
\begin_inset Formula $N$
\end_inset

's computation tree has length at most 
\begin_inset Formula $t\left(n\right)$
\end_inset

 and at every node in the computation path there are some finite number
 
\begin_inset Formula $b$
\end_inset

 of outgoing edges given by 
\begin_inset Formula $N$
\end_inset

's transition function.
 Therefore the total number of leaves in 
\begin_inset Formula $N$
\end_inset

's computation tree is.
 The deterministic TM traverses 
\begin_inset Formula $N$
\end_inset

's computation tree in a breadfirst manner.
 The total number of nodes in the entire tree is less than twice the maximum
 number of leaves 
\begin_inset Formula $b^{O\left(t\left(n\right)\right)}$
\end_inset

(because it's a binary tree or something like that) and hence is 
\begin_inset Formula $O\left(b^{t\left(n\right)}\right)$
\end_inset

.
 The time taken to travel to a node is 
\begin_inset Formula $O\left(t\left(n\right)\right)$
\end_inset

 and therefore the total time of the BFS is 
\begin_inset Formula 
\[
O\left(t\left(n\right)b^{t\left(n\right)}\right)=2^{O\left(t\left(n\right)\right)}
\]

\end_inset


\end_layout

\begin_layout Proof
(subproof: let 
\begin_inset Formula $f_{1}\left(n\right)=O\left(t\left(n\right)\right)$
\end_inset

 and 
\begin_inset Formula $f_{2}\left(n\right)=b^{t\left(n\right)}$
\end_inset

.
 By definition there exist constants 
\begin_inset Formula $c_{1},c_{2},N_{1},N_{2}$
\end_inset

 such that for 
\begin_inset Formula $n\geq\max\left\{ N_{1},N_{2}\right\} $
\end_inset

 
\begin_inset Formula 
\[
f_{1}\left(n\right)f_{2}\left(n\right)\leq c_{1}c_{2}t\left(n\right)b^{t\left(n\right)}=c_{0}t\left(n\right)b^{t\left(n\right)}
\]

\end_inset

and then
\begin_inset Formula 
\begin{align*}
c_{0}t\left(n\right)b^{t\left(n\right)} & =2^{\log_{2}\left(c_{0}t\left(n\right)b^{t\left(n\right)}\right)}\\
 & =2^{\log_{2}\left(c_{0}\right)+\log_{2}\left(t\left(n\right)\right)+t\left(n\right)\log_{2}\left(b\right)}\\
 & =2^{O\left(t\left(n\right)\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Definition*
The language class
\begin_inset Formula 
\[
\text{P}\coloneqq\bigcup_{k}\text{DTIME}\left(n^{k}\right)
\]

\end_inset

is the class of languages decidable in polynomial time on a deterministic
 single-tape TM.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition*
A 
\emph on
verifier 
\emph default
for a
\emph on
 
\emph default
language 
\begin_inset Formula $A$
\end_inset

 is an algorithm 
\begin_inset Formula $V$
\end_inset

 such that 
\begin_inset Formula $x\in A$
\end_inset

 iff there exists a certificate 
\begin_inset Formula $c$
\end_inset

 such that 
\begin_inset Formula $V$
\end_inset

 accepts 
\begin_inset Formula $\left(w,c\right)$
\end_inset

, or 
\begin_inset Formula $\left\langle w,v\right\rangle \in L\left(V\right)$
\end_inset

.
 If the verifier, i.e.
 the TM 
\begin_inset Formula $V$
\end_inset

, runs in polynomial time in the 
\begin_inset Formula $\left|x\right|$
\end_inset

 then 
\begin_inset Formula $A$
\end_inset

 is called polynomially verifiable.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition*
The language class
\begin_inset Formula 
\[
\text{NP}\coloneqq\bigcup_{k}\text{NTIME}\left(n^{k}\right)
\]

\end_inset

is the class of languages decidable in polynomial time on a nondeterministic
 single-tape TM.
\end_layout

\begin_layout Theorem*
A language is in NP iff it is polynomially verifiable.
\end_layout

\begin_layout Proof
Assume 
\begin_inset Formula $A$
\end_inset

 is decided by a polynomial time NTM 
\begin_inset Formula $N$
\end_inset

.
 Construct the verifier 
\begin_inset Formula $V$
\end_inset

 to be the machine that on input 
\begin_inset Formula $\left\langle w,c\right\rangle $
\end_inset

 (where 
\begin_inset Formula $c$
\end_inset

 is the computational path that 
\begin_inset Formula $N$
\end_inset

 takes in accepting 
\begin_inset Formula $w$
\end_inset

).
 The verifier first simulates 
\begin_inset Formula $N$
\end_inset

 on 
\begin_inset Formula $w$
\end_inset

, using 
\begin_inset Formula $c$
\end_inset

.
 If 
\begin_inset Formula $N$
\end_inset

 accepts then 
\begin_inset Formula $V$
\end_inset

 accepts.
 Otherwise it rejects.
 Clearly 
\begin_inset Formula $V$
\end_inset

 is a polynomial time verifier since each computational path in an NTM is
 polynomial in the input.
 For the reverse direction let 
\begin_inset Formula $V$
\end_inset

 be a polynomial time verifier for 
\begin_inset Formula $A$
\end_inset

 and we show that 
\begin_inset Formula $A$
\end_inset

 is decided by a polynomial time NTM 
\begin_inset Formula $N$
\end_inset

.
 Assume 
\begin_inset Formula $V$
\end_inset

 runs in 
\begin_inset Formula $n^{k}$
\end_inset

 time and construct 
\begin_inset Formula $N$
\end_inset

 to be the machine that on input of length 
\begin_inset Formula $n$
\end_inset

 guesses the certificate of length 
\begin_inset Formula $n^{k}$
\end_inset

 and simulates 
\begin_inset Formula $V$
\end_inset

 on 
\begin_inset Formula $\left\langle w,c\right\rangle $
\end_inset

.
 If 
\begin_inset Formula $V$
\end_inset

 accepts then accept, otherwise reject.
\end_layout

\begin_layout Standard
Examples of problems in NP are: 
\begin_inset Formula $k$
\end_inset

-clique (the set of graphs that have at least a 
\begin_inset Formula $k$
\end_inset

-clique), subset-sum (whether a set has a subset that sums to some number
 
\begin_inset Formula $t$
\end_inset

).
\end_layout

\begin_layout Theorem*
For 
\begin_inset Formula 
\[
\text{EXPTIME}=\bigcup_{k}\text{TIME}\left(2^{n^{k}}\right)
\]

\end_inset

it's the case that 
\begin_inset Formula $\text{NP}\subset\text{EXPTIME}$
\end_inset

.
\end_layout

\begin_layout Definition*
Let 
\begin_inset Formula $M$
\end_inset

 be a deterministic TM that halts on all inputs.
 The 
\emph on
space complexity
\emph default
 
\begin_inset Formula $f\left(n\right)$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

 is the maximum number of tape cells that 
\begin_inset Formula $M$
\end_inset

 scans on any input of size 
\begin_inset Formula $n$
\end_inset

.
 For a NTM 
\begin_inset Formula $M$
\end_inset

 the space complexity is the maximum number of tape cells that 
\begin_inset Formula $M$
\end_inset

 scans on any branch of its computation for any input of length 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition*
The 
\emph on
space complexity classes
\emph default

\begin_inset Formula 
\[
\text{SPACE}\left(f\left(n\right)\right)=\left\{ L\big|L\text{ is a language decided by a }O\left(f\left(n\right)\right)\text{ space DTM}\right\} 
\]

\end_inset


\begin_inset Formula 
\[
\text{NSPACE}\left(f\left(n\right)\right)=\left\{ L\big|L\text{ is a language decided by a }O\left(f\left(n\right)\right)\text{ space NTM}\right\} 
\]

\end_inset


\end_layout

\begin_layout Theorem*
Some 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 complexity inclusions
\begin_inset Formula 
\[
\text{DTIME(SPACE)}\left(f\left(n\right)\right)\subset\text{NTIME(SPACE)}\left(f\left(n\right)\right)
\]

\end_inset

This is obvious since a deterministic machine is also a nondeterministic
 machine.
\begin_inset Formula 
\[
\text{NTIME}\left(f\left(n\right)\right)\subset\text{DTIME}\left(2^{O\left(f\left(n\right)\right)}\right)
\]

\end_inset

This was proved above.
 
\begin_inset Formula 
\[
\text{(N)DTIME}\left(f\left(n\right)\right)\subset\text{(N)DSPACE}\left(f\left(n\right)\right)\subset\text{(N)DTIME}\left(2^{O\left(f\left(n\right)\right)}\right)
\]

\end_inset

This one is not so obvious?
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Theorem*
Sitvich's theorem
\begin_inset Formula 
\[
\text{NSPACE}\left(f\left(n\right)\right)\subset\text{DSPACE}\left(f^{2}\left(n\right)\right)
\]

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Theorem*
Hierarchy theorems: if 
\begin_inset Formula $f=o\left(g\right)$
\end_inset

 then
\begin_inset Formula 
\[
\text{(N)DSPACE}\left(f\left(n\right)\right)\subsetneq\text{(N)DSPACE}\left(g\left(n\right)\right)
\]

\end_inset

and if 
\begin_inset Formula $f\log f=o\left(g\right)$
\end_inset

 then
\begin_inset Formula 
\[
\text{(N)DTIME}\left(f\left(n\right)\right)\subsetneq\text{(N)DTIME}\left(g\left(n\right)\right)
\]

\end_inset


\end_layout

\begin_layout Section
Reductions
\end_layout

\begin_layout Enumerate
Set splitting: problem statement is for a given set can you construct subsets
 such that not all elements in the subset are colored the same.
 To prove NP complete the reduction is from 3SAT: let the set be all of
 the literals plus a dummy variable 
\begin_inset Formula $y$
\end_inset

.
 Then the subsets are all the literals in a clause plus 
\begin_inset Formula $y$
\end_inset

 (in each such set) and sets with the literal and its negation.
 Then If 3SAT has a satisfying assignment color all literals which are true
 to be red and 
\begin_inset Formula $y$
\end_inset

 to be blue.
 Then if all literals in a clause are true there will be at least one blue
 colored object.
 Further the clauses that have just the variables can't be one color.
 Conversely if there's a coloring then pick those variables to be true which
 are opposite of the color of 
\begin_inset Formula $y$
\end_inset

 generates a satisfying assignment (since there will be at least 1 and hence
 each clause will be satisfied).
\end_layout

\begin_layout Enumerate
Factoring in poly time if P=NP: Let 
\begin_inset Formula $F=\left\{ \left\langle a,b,c\right\rangle \big|a=pq\wedge b\leq p\leq c\right\} $
\end_inset

.
 If P=NP then the polynomial hierarchy collapses and 
\begin_inset Formula $F$
\end_inset

 is somewhere in P.
 Then we can just binary search from 
\begin_inset Formula $b=1\leq p\leq c=a$
\end_inset

 to find a 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Enumerate
Generate a satisfying assignment for SAT if P=NP: alternatively choose 
\begin_inset Formula $x_{i}=1$
\end_inset

 and 
\begin_inset Formula $x_{i}=0$
\end_inset

 and check for satisfying assignment using polynomial time algo for SAT.
\end_layout

\begin_layout Enumerate
MAXCLIQUE in polynomial time if P=NP: use clique iterating through numbers
 
\begin_inset Formula $k=1,\dots,\left|V\right|$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $U=\left\{ \left(M,x,1^{t}\right)\big|\text{M accepts x in time less than t}\right\} $
\end_inset

 is NP-complete.
 
\begin_inset Formula $U$
\end_inset

 is in NP because we can use an NTM to simulate 
\begin_inset Formula $M$
\end_inset

 on 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $U$
\end_inset

 will be polynomial in its input because 
\begin_inset Formula $1^{t}$
\end_inset

 padding pushes up the size of the input.
 
\begin_inset Formula $U$
\end_inset

 is NP-hard because 3SAT reduces to it: let 
\begin_inset Formula $M$
\end_inset

 be an NTM that decides 3SAT in 
\begin_inset Formula $cn^{k}$
\end_inset

.
 Then 
\begin_inset Formula $U$
\end_inset

 decides 
\begin_inset Formula $\left(M,\phi,1^{c\left|\phi\right|^{k}}\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
Puzzle: reduce 3SAT to it: let there be 2 columns with number of rows equal
 to number of clauses.
 1 punch card for each variable.
 Then punch out those holes where 
\begin_inset Formula $x_{i}$
\end_inset

 nor 
\begin_inset Formula $\overline{x_{i}}$
\end_inset

 is not in the clause and leaves not punched out rows in column 1 where
 
\begin_inset Formula $x_{i}$
\end_inset

 appears and rows in column 2 where 
\begin_inset Formula $\overline{x_{i}}$
\end_inset

 appears.
 Also add a card with column two completely filled and column 1 completely
 empty.
 Then a satisfying assignment solves the puzzle with the hack card left
 anywhere and if there's a solution to the puzzle just flip the deck of
 cards so that the hack card lies on the right hand side and assign true
 to the values that appear not punched out in the other column.
\end_layout

\begin_layout Enumerate
MODEXP is in P: use repeated squaring to test
\end_layout

\begin_layout Enumerate
P is closed under star: use the DP algorithm that checks characters 
\begin_inset Formula $w_{1}\cdots w_{n}$
\end_inset

 by checking for 
\begin_inset Formula $w_{i}\cdots w_{j}$
\end_inset

 being in the language (while iterating through all possible choices of
 break and word length).
\end_layout

\begin_layout Enumerate
NP is closed under star: the NTM can just guess the number of substrings
 and where to split and check in original language.
\end_layout

\begin_layout Enumerate
SUBSETSUM: the dumb dp algorithm is to construct all sums: let 
\begin_inset Formula $L_{i}$
\end_inset

 be the set of possible sums made from 
\begin_inset Formula $i$
\end_inset

 elements.
 Then 
\begin_inset Formula $L_{0}=0$
\end_inset

 and 
\begin_inset Formula $L_{i}=L_{i-1}\cup\left\{ a+x_{i}\big|a\in L_{i-1}\right\} $
\end_inset

.
 Then check iterate through and look.
 The fast algorithm is construct a table 
\begin_inset Formula $Q\left(i,s\right)$
\end_inset

 which is boolean for whether there's a subset in the first 
\begin_inset Formula $i$
\end_inset

 elements that sums to 
\begin_inset Formula $s$
\end_inset

.
 Then 
\begin_inset Formula 
\[
Q\left(i,s\right)=Q\left(i-1,s\right)\vee\left(x_{i}==s\right)\vee Q\left(i-1,s-x_{i}\right)
\]

\end_inset

Note that at any point you can set entries to zero if 
\begin_inset Formula $s<A$
\end_inset

 or 
\begin_inset Formula $s>B$
\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 is the sum of all the negative numbers and 
\begin_inset Formula $B$
\end_inset

 is the sum of the positive numbers.
 Runs in 
\begin_inset Formula $O\left(tN\right)$
\end_inset

 time.
\end_layout

\begin_layout Enumerate
SPATH: shortest path: use dijkstra's using min priority queue (based on
 fib heap) which has running time 
\begin_inset Formula $O\left(\left|E\right|+\left|V\right|\log\left|V\right|\right)$
\end_inset

 (update the distance in the min priority queue of all neighbors of currently
 being explored node).
\end_layout

\begin_layout Enumerate
LPATH: NP-complete by asking if there's a path that includes 
\begin_inset Formula $k$
\end_inset

 vertices (because that's a hamiltonian cycle) since LPATH is about simple
 paths.
\end_layout

\begin_layout Enumerate
3SAT 
\begin_inset Formula $\leq_{m}^{p}$
\end_inset

 Clique: each literal is a node and edges connect all pairs of nodes in
 different clusters (except a variable to its negation).
 Then a 
\begin_inset Formula $k$
\end_inset

 clique where 
\begin_inset Formula $k$
\end_inset

 is the number of clauses is a satisfying assignment.
\end_layout

\begin_layout Enumerate
Vertex-cover 
\begin_inset Formula $\leq_{m}^{p}$
\end_inset

 clique by looking at the complement graph: 
\begin_inset Formula $\left(v,u\right)\in E'$
\end_inset

 iff 
\begin_inset Formula $\left(v,u\right)\notin E$
\end_inset

.
 If there's a clique in 
\begin_inset Formula $E$
\end_inset

 of size 
\begin_inset Formula $k$
\end_inset

 the there's a vertex cover of size 
\begin_inset Formula $\left|V\right|-k$
\end_inset

 in 
\begin_inset Formula $G'$
\end_inset

.
 and vice versa.
\end_layout

\begin_layout Enumerate
Vertex-cover 
\begin_inset Formula $\leq_{m}^{p}$
\end_inset

 dominating set: add triangle that associates spurious node with edge.
\end_layout

\begin_layout Enumerate
Connected: in P by using BFS and scanning afterward to see if all nodes
 visited.
\end_layout

\begin_layout Enumerate
3 Clique: try all triplets of vertices checking for edges: 
\begin_inset Formula ${m \choose 3}=\frac{m!}{3!\left(m-3\right)!}\approx m^{3}$
\end_inset


\end_layout

\begin_layout Enumerate
ISOMORPHISM is in NP by checking whether hte permutation is such that 
\begin_inset Formula $\left(x,y\right)\in E$
\end_inset

 iff 
\begin_inset Formula $\left(\pi\left(x\right),\pi\left(y\right)\right)\in E'$
\end_inset

.
\end_layout

\begin_layout Enumerate
DOUBLESAT: take on 
\begin_inset Formula $\phi\wedge\left(x\vee\bar{x}\right)$
\end_inset

 then there are two satisfying assignments.
\end_layout

\begin_layout Enumerate
PERMUTATION: use repeated squaring.
\end_layout

\begin_layout Enumerate
HALF-CLIQUE: if 
\begin_inset Formula $k=m/2$
\end_inset

 then just pass to half clique.
 If 
\begin_inset Formula $k<m/2$
\end_inset

 then add a complete graph (with edges to every vertex) of 
\begin_inset Formula $\left(m-2k\right)$
\end_inset

 vertices.
 Then if a 
\begin_inset Formula $k$
\end_inset

 clique exists it's a half clique because 
\begin_inset Formula $k+\left(m-2k\right)=m-k=\frac{2\left(m-k\right)}{2}$
\end_inset

 where 
\begin_inset Formula $2m-2k$
\end_inset

 is the total number of vertices.
 If 
\begin_inset Formula $k>m/2$
\end_inset

 then add a complete graph with 
\begin_inset Formula $2k-m$
\end_inset

 edges.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\neq$
\end_inset

assignment: reduce from 3SAT 
\begin_inset Formula $\left(y_{1}\vee y_{2}\vee y_{3}\right)\rightarrow\left(y_{1}\vee y_{2}\vee z_{i}\right)\wedge\left(\bar{z}_{i}\vee y_{3}\vee b\right)$
\end_inset

.
 Since any satisfying assignment of neq sat can be negated to produce another
 one we can select 
\begin_inset Formula $b=0$
\end_inset

 (just flip).
\end_layout

\begin_layout Enumerate
Poly with integer root is NP-hard: reduce from 3SAT: create polynomials
 simulating the boolean formula with 
\begin_inset Formula $x_{i}=x_{i}$
\end_inset

 and 
\begin_inset Formula $\overline{x_{i}}=1-x_{i}$
\end_inset

 and 
\begin_inset Formula $x_{i}\wedge x_{j}=x_{i}x_{j}$
\end_inset

 and 
\begin_inset Formula $x_{i}\vee x_{j}=\left(1-\left(1-x_{i}\right)\left(1-x_{j}\right)\right)$
\end_inset

.
 But enforce integer roots with 
\begin_inset Formula $r=\left(x_{1}\left(1-x_{i}\right)\right)^{2}\cdots\left(x_{n}\left(1-x_{n}\right)\right)^{2}$
\end_inset


\end_layout

\begin_layout Enumerate
2CNF: 
\begin_inset Formula $\left(x\vee y\right)\iff\left(\bar{x}\Rightarrow y\right)$
\end_inset

 and 
\begin_inset Formula $\left(\bar{y}\Rightarrow x\right)$
\end_inset

.
 Then look for cycles that include 
\begin_inset Formula $\bar{x}\Rightarrow x\Rightarrow\bar{x}$
\end_inset

.
 To construct a satisfying assignment look for 
\begin_inset Formula $x\Rightarrow\bar{x}$
\end_inset

.
 If exists then set 
\begin_inset Formula $\bar{x}$
\end_inset

 to true.
 Otherwise set 
\begin_inset Formula $x$
\end_inset

 to true.
 set all other implications true.
 Then repeat.
\end_layout

\end_body
\end_document
