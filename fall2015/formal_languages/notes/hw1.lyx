#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass amsart
\begin_preamble

%
\usepackage{amsfonts}
\usepackage{mathabx}
\usepackage{nopageno}%%%  The following few lines affect the margin sizes. 
\usepackage{bm}
\addtolength{\topmargin}{-.5in}
\setlength{\textwidth}{6in}       
\setlength{\oddsidemargin}{.25in}              
\setlength{\evensidemargin}{.25in}         
  
\setlength{\textheight}{9in}
\renewcommand{\baselinestretch}{1}
\reversemarginpar   
%
%
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 2
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Notes
\end_layout

\begin_layout Author
Maksim Levental
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Definition*
For functions 
\begin_inset Formula $f,g$
\end_inset

 if there exist 
\begin_inset Formula $c,N\in\mathbb{N}$
\end_inset

 such that for every 
\begin_inset Formula $n\geq N$
\end_inset

 
\begin_inset Formula 
\[
f\left(n\right)\leq cg\left(n\right)
\]

\end_inset

then 
\begin_inset Formula $f\in O\left(g\left(n\right)\right)$
\end_inset

 or 
\begin_inset Formula $f=O\left(g\left(n\right)\right)$
\end_inset

.
 Alternatively if 
\begin_inset Formula 
\[
\lim_{n\rightarrow\infty}\frac{f\left(n\right)}{g\left(n\right)}<\infty
\]

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition*
For functions 
\begin_inset Formula $f,g$
\end_inset

 if for all 
\begin_inset Formula $c>0$
\end_inset

 there exist 
\begin_inset Formula $N\in\mathbb{N}$
\end_inset

 such that for every 
\begin_inset Formula $n\geq N$
\end_inset

 
\begin_inset Formula 
\[
f\left(n\right)<cg\left(n\right)
\]

\end_inset

then 
\begin_inset Formula $f\in o\left(g\left(n\right)\right)$
\end_inset

 or 
\begin_inset Formula $f=o\left(g\left(n\right)\right)$
\end_inset

.
 Alternatively if 
\begin_inset Formula 
\[
\lim_{n\rightarrow\infty}\frac{f\left(n\right)}{g\left(n\right)}=0
\]

\end_inset


\end_layout

\begin_layout Standard
We can count the number of 
\begin_inset Quotes eld
\end_inset

steps
\begin_inset Quotes erd
\end_inset

 a TM takes to decide a language.
 This suggests the notion of time complexity classes:
\end_layout

\begin_layout Definition*
Let 
\begin_inset Formula $t:\mathbb{N}\rightarrow\mathbb{N}$
\end_inset

.
 Then the time complexity class
\begin_inset Formula 
\[
\text{TIME}\left(t\left(n\right)\right)\coloneqq\left\{ L\big|L\text{ is a language decided by a }O\left(t\left(n\right)\right)\text{ time Turing machine}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $\text{TIME}\left(t\left(n\right)\right)$
\end_inset

 is a class of languages, i.e.
 class of sets.
 This definition of running time for a nondeterministic TM has to be defined
 differently since an NTM just guesses the right path:
\end_layout

\begin_layout Definition*
Let 
\begin_inset Formula $N$
\end_inset

 be a nondeterministic TM that always halts.
 Then the running time 
\begin_inset Formula $f\left(n\right)$
\end_inset

 of 
\begin_inset Formula $N$
\end_inset

 is the maximum number of steps that 
\begin_inset Formula $N$
\end_inset

 uses on any branch of its computation on any input of length 
\begin_inset Formula $n$
\end_inset

.
 If you think of a nondeterministic TM as a computational tree that guesses
 the right computation path (or tries all computational pathes simultaneously)
 then the running time of the NTM is the longest path (even if it rejects).
\end_layout

\begin_layout Theorem*
\begin_inset Formula $\text{NTIME}\left(t\left(n\right)\right)\subset\text{DTIME}\left(2^{O\left(t\left(n\right)\right)}\right)$
\end_inset


\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $N$
\end_inset

 be an NTM with running time 
\begin_inset Formula $t\left(n\right)$
\end_inset

.
 By equivalence of TMs we can construct a deterministic TM that decides
 the same langauge as 
\begin_inset Formula $N$
\end_inset

.
 Consider the constrution: on any input of length 
\begin_inset Formula $n$
\end_inset

 the computation path in 
\begin_inset Formula $N$
\end_inset

's computation tree has length at most 
\begin_inset Formula $t\left(n\right)$
\end_inset

 and at every node in the computation path there are some finite number
 
\begin_inset Formula $b$
\end_inset

 of outgoing edges given by 
\begin_inset Formula $N$
\end_inset

's transition function.
 Therefore the total number of leaves in 
\begin_inset Formula $N$
\end_inset

's computation tree is.
 The deterministic TM traverses 
\begin_inset Formula $N$
\end_inset

's computation tree in a breadfirst manner.
 The total number of nodes in the entire tree is less than twice the maximum
 number of leaves 
\begin_inset Formula $b^{O\left(t\left(n\right)\right)}$
\end_inset

(because it's a binary tree or something like that) and hence is 
\begin_inset Formula $O\left(b^{t\left(n\right)}\right)$
\end_inset

.
 The time taken to travel to a node is 
\begin_inset Formula $O\left(t\left(n\right)\right)$
\end_inset

 and therefore the total time of the BFS is 
\begin_inset Formula 
\[
O\left(t\left(n\right)b^{t\left(n\right)}\right)=2^{O\left(t\left(n\right)\right)}
\]

\end_inset


\end_layout

\begin_layout Proof
(subproof: let 
\begin_inset Formula $f_{1}\left(n\right)=O\left(t\left(n\right)\right)$
\end_inset

 and 
\begin_inset Formula $f_{2}\left(n\right)=b^{t\left(n\right)}$
\end_inset

.
 By definition there exist constants 
\begin_inset Formula $c_{1},c_{2},N_{1},N_{2}$
\end_inset

 such that for 
\begin_inset Formula $n\geq\max\left\{ N_{1},N_{2}\right\} $
\end_inset

 
\begin_inset Formula 
\[
f_{1}\left(n\right)f_{2}\left(n\right)\leq c_{1}c_{2}t\left(n\right)b^{t\left(n\right)}=c_{0}t\left(n\right)b^{t\left(n\right)}
\]

\end_inset

and then
\begin_inset Formula 
\begin{align*}
c_{0}t\left(n\right)b^{t\left(n\right)} & =2^{\log_{2}\left(c_{0}t\left(n\right)b^{t\left(n\right)}\right)}\\
 & =2^{\log_{2}\left(c_{0}\right)+\log_{2}\left(t\left(n\right)\right)+t\left(n\right)\log_{2}\left(b\right)}\\
 & =2^{O\left(t\left(n\right)\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Definition*
The language class
\begin_inset Formula 
\[
\text{P}\coloneqq\bigcup_{k}\text{DTIME}\left(n^{k}\right)
\]

\end_inset

is the class of languages decidable in polynomial time on a deterministic
 single-tape TM.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition*
A 
\emph on
verifier 
\emph default
for a
\emph on
 
\emph default
language 
\begin_inset Formula $A$
\end_inset

 is an algorithm 
\begin_inset Formula $V$
\end_inset

 such that 
\begin_inset Formula $x\in A$
\end_inset

 iff there exists a certificate 
\begin_inset Formula $c$
\end_inset

 such that 
\begin_inset Formula $V$
\end_inset

 accepts 
\begin_inset Formula $\left(w,c\right)$
\end_inset

, or 
\begin_inset Formula $\left\langle w,v\right\rangle \in L\left(V\right)$
\end_inset

.
 If the verifier, i.e.
 the TM 
\begin_inset Formula $V$
\end_inset

, runs in polynomial time in the 
\begin_inset Formula $\left|x\right|$
\end_inset

 then 
\begin_inset Formula $A$
\end_inset

 is called polynomially verifiable.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition*
The language class
\begin_inset Formula 
\[
\text{NP}\coloneqq\bigcup_{k}\text{NTIME}\left(n^{k}\right)
\]

\end_inset

is the class of languages decidable in polynomial time on a nondeterministic
 single-tape TM.
\end_layout

\begin_layout Theorem*
A language is in NP iff it is polynomially verifiable.
\end_layout

\begin_layout Proof
Assume 
\begin_inset Formula $A$
\end_inset

 is decided by a polynomial time NTM 
\begin_inset Formula $N$
\end_inset

.
 Construct the verifier 
\begin_inset Formula $V$
\end_inset

 to be the machine that on input 
\begin_inset Formula $\left\langle w,c\right\rangle $
\end_inset

 (where 
\begin_inset Formula $c$
\end_inset

 is the computational path that 
\begin_inset Formula $N$
\end_inset

 takes in accepting 
\begin_inset Formula $w$
\end_inset

).
 The verifier first simulates 
\begin_inset Formula $N$
\end_inset

 on 
\begin_inset Formula $w$
\end_inset

, using 
\begin_inset Formula $c$
\end_inset

.
 If 
\begin_inset Formula $N$
\end_inset

 accepts then 
\begin_inset Formula $V$
\end_inset

 accepts.
 Otherwise it rejects.
 Clearly 
\begin_inset Formula $V$
\end_inset

 is a polynomial time verifier since each computational path in an NTM is
 polynomial in the input.
 For the reverse direction let 
\begin_inset Formula $V$
\end_inset

 be a polynomial time verifier for 
\begin_inset Formula $A$
\end_inset

 and we show that 
\begin_inset Formula $A$
\end_inset

 is decided by a polynomial time NTM 
\begin_inset Formula $N$
\end_inset

.
 Assume 
\begin_inset Formula $V$
\end_inset

 runs in 
\begin_inset Formula $n^{k}$
\end_inset

 time and construct 
\begin_inset Formula $N$
\end_inset

 to be the machine that on input of length 
\begin_inset Formula $n$
\end_inset

 guesses the certificate of length 
\begin_inset Formula $n^{k}$
\end_inset

 and simulates 
\begin_inset Formula $V$
\end_inset

 on 
\begin_inset Formula $\left\langle w,c\right\rangle $
\end_inset

.
 If 
\begin_inset Formula $V$
\end_inset

 accepts then accept, otherwise reject.
\end_layout

\begin_layout Standard
Examples of problems in NP are: 
\begin_inset Formula $k$
\end_inset

-clique (the set of graphs that have at least a 
\begin_inset Formula $k$
\end_inset

-clique), subset-sum (whether a set has a subset that sums to some number
 
\begin_inset Formula $t$
\end_inset

).
\end_layout

\begin_layout Theorem*
For 
\begin_inset Formula 
\[
\text{EXPTIME}=\bigcup_{k}\text{TIME}\left(2^{n^{k}}\right)
\]

\end_inset

it's the case that 
\begin_inset Formula $\text{NP}\subset\text{EXPTIME}$
\end_inset

.
\end_layout

\begin_layout Definition*
Let 
\begin_inset Formula $M$
\end_inset

 be a deterministic TM that halts on all inputs.
 The 
\emph on
space complexity
\emph default
 
\begin_inset Formula $f\left(n\right)$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

 is the maximum number of tape cells that 
\begin_inset Formula $M$
\end_inset

 scans on any input of size 
\begin_inset Formula $n$
\end_inset

.
 For a NTM 
\begin_inset Formula $M$
\end_inset

 the space complexity is the maximum number of tape cells that 
\begin_inset Formula $M$
\end_inset

 scans on any branch of its computation for any input of length 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition*
The 
\emph on
space complexity classes
\emph default

\begin_inset Formula 
\[
\text{SPACE}\left(f\left(n\right)\right)=\left\{ L\big|L\text{ is a language decided by a }O\left(f\left(n\right)\right)\text{ space DTM}\right\} 
\]

\end_inset


\begin_inset Formula 
\[
\text{NSPACE}\left(f\left(n\right)\right)=\left\{ L\big|L\text{ is a language decided by a }O\left(f\left(n\right)\right)\text{ space NTM}\right\} 
\]

\end_inset


\end_layout

\begin_layout Theorem*
Some 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 complexity inclusions
\begin_inset Formula 
\[
\text{DTIME(SPACE)}\left(f\left(n\right)\right)\subset\text{NTIME(SPACE)}\left(f\left(n\right)\right)
\]

\end_inset

This is obvious since a deterministic machine is also a nondeterministic
 machine.
\begin_inset Formula 
\[
\text{NTIME}\left(f\left(n\right)\right)\subset\text{DTIME}\left(2^{O\left(f\left(n\right)\right)}\right)
\]

\end_inset

This was proved above.
 
\begin_inset Formula 
\[
\text{(N)DTIME}\left(f\left(n\right)\right)\subset\text{(N)DSPACE}\left(f\left(n\right)\right)\subset\text{(N)DTIME}\left(2^{O\left(f\left(n\right)\right)}\right)
\]

\end_inset

This one is not so obvious?
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Theorem*
Sitvich's theorem
\begin_inset Formula 
\[
\text{NSPACE}\left(f\left(n\right)\right)\subset\text{DSPACE}\left(f^{2}\left(n\right)\right)
\]

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Theorem*
Hierarchy theorems: if 
\begin_inset Formula $f=o\left(g\right)$
\end_inset

 then
\begin_inset Formula 
\[
\text{(N)DSPACE}\left(f\left(n\right)\right)\subsetneq\text{(N)DSPACE}\left(g\left(n\right)\right)
\]

\end_inset

and if 
\begin_inset Formula $f\log f=o\left(g\right)$
\end_inset

 then
\begin_inset Formula 
\[
\text{(N)DTIME}\left(f\left(n\right)\right)\subsetneq\text{(N)DTIME}\left(g\left(n\right)\right)
\]

\end_inset


\end_layout

\end_body
\end_document
