#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble

%
\usepackage{mathdots}
\usepackage{listings}
\usepackage{tikz}
\usepackage{pgf}
\usepackage{tikz-qtree}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{amsfonts}\usepackage{nopageno}%%%  The following few lines affect the margin sizes. 
\addtolength{\topmargin}{-.5in}
\setlength{\textwidth}{6in}       
\setlength{\oddsidemargin}{.25in}              
\setlength{\evensidemargin}{.25in}         
  
\setlength{\textheight}{9in}
\renewcommand{\baselinestretch}{1}
\reversemarginpar   

\lstset{
numbers=left
}


%
%
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=single"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
COT5405 Homework 2 Solutions
\end_layout

\begin_layout Author
Maksim Levental
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[6-3]
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $Y[1,1]=\infty$
\end_inset

 then the only entries that can appear in 
\begin_inset Formula $Y[1,j]$
\end_inset

 for 
\begin_inset Formula $j>1$
\end_inset

 are 
\begin_inset Formula $\infty$
\end_inset

 by the requirement that 
\begin_inset Formula $Y[1,j]\leq Y[1,j+1]$
\end_inset

 and similarly the only entries that can appear in 
\begin_inset Formula $Y[i,1]$
\end_inset

 for 
\begin_inset Formula $i>1$
\end_inset

 are 
\begin_inset Formula $\infty$
\end_inset

.
 Hence by induction/recursion all of the entries in the tableaux are 
\begin_inset Formula $\infty$
\end_inset

.
 If 
\begin_inset Formula $Y[m,n]<\infty$
\end_inset

 then no entries equal to 
\begin_inset Formula $\infty$
\end_inset

 can appear in 
\begin_inset Formula $Y[m,j]$
\end_inset

 for 
\begin_inset Formula $j<n$
\end_inset

 by the requirement that 
\begin_inset Formula $Y[1,j]\leq Y[1,j+1]$
\end_inset

 and similarly no entries equal to 
\begin_inset Formula $\infty$
\end_inset

 can appear in 
\begin_inset Formula $Y[i,n]$
\end_inset

 for 
\begin_inset Formula $i<n$
\end_inset

.
 Hence by induction/recursion 
\begin_inset Formula $Y$
\end_inset

 is full.
\end_layout

\begin_layout Enumerate
The minimum element is at 
\begin_inset Formula $Y[1,1]$
\end_inset

.
 Remove/extract it and replace it with 
\begin_inset Formula $\infty$
\end_inset

.
 Consider the sub-tableaux 
\begin_inset Formula $Y_{ij}$
\end_inset

 of 
\begin_inset Formula $Y$
\end_inset

 with top-left corner at row 
\begin_inset Formula $i$
\end_inset

 and column 
\begin_inset Formula $j$
\end_inset

.
 After extracting the minimum 
\begin_inset Formula $Y[1,1]$
\end_inset

 and replacing it with 
\begin_inset Formula $\infty$
\end_inset

 compute the minima of 
\begin_inset Formula $Y_{i+1,j}$
\end_inset

 and 
\begin_inset Formula $Y_{i,j+1}$
\end_inset

 for 
\begin_inset Formula $i=j=1$
\end_inset

 and swap the 
\begin_inset Formula $\infty$
\end_inset

 in 
\begin_inset Formula $Y[1,1]$
\end_inset

 with the 
\begin_inset Formula $\min\{\text{Extract-Min(}Y_{1+1,1}),\text{Extract-Min(}Y_{1,1+1})\}$
\end_inset

.
 This is correct because it does not violate the Young-Tableaux property
 
\begin_inset Formula $Y$
\end_inset

 since you're picking the minimum of 
\begin_inset Formula $\{Y_{1+1,1},Y_{1,1+1}\}$
\end_inset

.
 The algorithm terminates when 
\begin_inset Formula $\infty=\min\{\text{Extract-Min(}Y_{i+1,j}),\text{Extract-Min(}Y_{i,j+1})\}$
\end_inset

 or 
\begin_inset Formula $i>m$
\end_inset

 and 
\begin_inset Formula $j>n$
\end_inset

.
 The recurrence relation is 
\begin_inset Formula 
\[
T(m+n)\leq\max\{T(m-1+n),T(m+n-1)\}+\Theta(1)
\]

\end_inset

Let 
\begin_inset Formula $p=m+n$
\end_inset

 then 
\begin_inset Formula 
\begin{align*}
T(p) & \leq\max\{T(p-1),T(p-1)\}+\Theta(1)\\
 & =T(p-1)+\Theta(1)
\end{align*}

\end_inset

Whose solution is clearly 
\begin_inset Formula $O(p)=O(m+n)$
\end_inset

.
\end_layout

\begin_layout Enumerate
By symmetry the maximum element in a Young-Tableaux is in the bottom-right
 entry.
 To insert replace the maximum element of 
\begin_inset Formula $Y$
\end_inset

 (by part (b) this entry is 
\begin_inset Formula $\infty$
\end_inset

).
 After extracting the maximum 
\begin_inset Formula $Y[m,n]$
\end_inset

 and replacing it with the entry to be inserted compute the maximum of 
\begin_inset Formula $Y[i-1,j]$
\end_inset

 and 
\begin_inset Formula $Y[i,j-1]$
\end_inset

 for 
\begin_inset Formula $i=m$
\end_inset

 and 
\begin_inset Formula $j=n$
\end_inset

 and swap the entry in 
\begin_inset Formula $Y[m,n]$
\end_inset

 with the 
\begin_inset Formula $\text{max}\{Y[m-1,n],Y[m,n-1]\}$
\end_inset

.
 If 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Y[m-1,n]=Y[m,n-1]$
\end_inset

 swap 
\begin_inset Formula $Y[m-1,n]$
\end_inset

 just to be definite.
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
Then repeat.
 This is correct because since you're picking the maximum of 
\begin_inset Formula $\{Y[m-1,n],Y[m,n-1]\}$
\end_inset

 and so at the end having 
\begin_inset Formula $Y[i-1,j]\text{ and }Y[i,j-1]$
\end_inset

 in the same column or row does not violate the Young-Tableaux property
 since 
\begin_inset Formula $\text{max}\{Y[i-1,j],Y[i,j-1]\}\geq Y[i-1,j]$
\end_inset

 and 
\begin_inset Formula $\text{max}\{Y[i-1,j],Y[i,j-1]\}\geq Y[i,j-1]$
\end_inset

.
 The algorithm terminates when the entry 
\begin_inset Formula $\geq\text{max}\{Y[m-1,n],Y[m,n-1]\}$
\end_inset

 or 
\begin_inset Formula $j<1$
\end_inset

 and 
\begin_inset Formula $j<1$
\end_inset

.
 Since at work the algorithm has to make comparisons with every entry in
 the last columns and every entry in the first row minus 1 the running time
 is 
\begin_inset Formula $O(m+n).$
\end_inset


\end_layout

\begin_layout Enumerate
Run Extract-Min for every one of the 
\begin_inset Formula $n^{2}$
\end_inset

 elements.
 The running time is 
\begin_inset Formula $n^{2}O(n+n)=n^{2}O(2n)=O(n^{3})$
\end_inset

.
\end_layout

\begin_layout Enumerate
Let 
\begin_inset Formula $x$
\end_inset

 be the entry we're searching for.
 Start at 
\begin_inset Formula $Y[1,1]$
\end_inset

 and proceed to 
\begin_inset Formula $\underset{Y[1,2],Y[2,1]}{\text{min}}\{|Y[1,1]-Y[2,1]|,|Y[1,1]-Y[1,2]|\}$
\end_inset

.
 In general proceed to 
\begin_inset Formula $\underset{Y[i,i+1],Y[i+1,j]}{\text{min}}\{|Y[i,j]-Y[i+1,j]|,|Y[i,j]-Y[i,j+1]|\}.$
\end_inset

 The search terminates if 
\begin_inset Formula $x=\underset{Y[i,i+1],Y[i+1,j]}{\text{min}}\{|Y[i,j]-Y[i+1,j]|,|Y[i,j]-Y[i,j+1]|\}$
\end_inset

 or 
\begin_inset Formula $x<\underset{Y[i,i+1],Y[i+1,j]}{\text{min}}\{|Y[i,j]-Y[i+1,j]|,|Y[i,j]-Y[i,j+1]|\}.$
\end_inset

 Proceeding in this way guarantees 
\begin_inset Formula $x$
\end_inset

 won't be skipped if it is present in the tableau.
 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[9.3-5]
\end_layout

\end_inset

Just implement the worst case linear time algorithm Select but replace steps
 1-3 with your linear time median algorithm.
 Another way to look at it is to implement Randomized-Select but forget
 the randomization and change partition to accept a pivot.
 The partition on whatever value Linear-Med returns
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Pivot-Partition(A,p,r,i)
\end_layout

\begin_layout Plain Layout

	//A[i] is the entry you want to partition around
\end_layout

\begin_layout Plain Layout

	swap(A[i],A[r])
\end_layout

\begin_layout Plain Layout

	return Partition(A,p,r)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Linear-Select(A,p,r,i)
\end_layout

\begin_layout Plain Layout

	if p == r
\end_layout

\begin_layout Plain Layout

		return A[p]
\end_layout

\begin_layout Plain Layout

	m = Linear-Med(A,p,r)
\end_layout

\begin_layout Plain Layout

	q = Pivot-Partition(A,p,r,m)
\end_layout

\begin_layout Plain Layout

	k = q-p+1
\end_layout

\begin_layout Plain Layout

	if i == k
\end_layout

\begin_layout Plain Layout

		return A[q]
\end_layout

\begin_layout Plain Layout

	else if i < k
\end_layout

\begin_layout Plain Layout

		return Linear-Select(A,p,q-1,i)
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		return Linear-Select(A,q+1,r,i-k)
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[9.3-7]
\end_layout

\end_inset

Modify Select to Select-Index, which return the index of the 
\begin_inset Formula $m$
\end_inset

th statistic instead of the value.
 Duplicate the array in linear time.
 Call the first array 
\begin_inset Formula $A$
\end_inset

 and the duplicated array 
\begin_inset Formula $B$
\end_inset

.
 Use Select or Select-Index to find the median 
\begin_inset Formula $m$
\end_inset

 in 
\begin_inset Formula $O(n)$
\end_inset

 time of 
\begin_inset Formula $A$
\end_inset

 then in linear time subtract 
\begin_inset Formula $m$
\end_inset

 from all elements in 
\begin_inset Formula $A$
\end_inset

 and compute their absolute value.
 The 
\begin_inset Formula $k$
\end_inset

 smallest elements then correspond to the closest to the median from the
 original array (which are stored in 
\begin_inset Formula $B$
\end_inset

).
 Compute the index of the 
\begin_inset Formula $k$
\end_inset

th order statistic of this new array.
 Then use a modified version of Partition to Double-Pivot-Partition that
 partitions 
\begin_inset Formula $A$
\end_inset

 but also performs the same swaps in 
\begin_inset Formula $B$
\end_inset

 which stores the original elements, i.e.
 partitions 
\begin_inset Formula $B$
\end_inset

 the same way as 
\begin_inset Formula $A$
\end_inset

.
 which was median centered.
 Then the first 
\begin_inset Formula $k$
\end_inset

 elements in 
\begin_inset Formula $B$
\end_inset

 are elements in the original array that were the 
\begin_inset Formula $k$
\end_inset

 closest to the median.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Double-Partition(A,B,p,r)
\end_layout

\begin_layout Plain Layout

	x = A[r]
\end_layout

\begin_layout Plain Layout

	i = p-1
\end_layout

\begin_layout Plain Layout

	for j = p to r-1 
\end_layout

\begin_layout Plain Layout

		if A[j] <= x
\end_layout

\begin_layout Plain Layout

			i = i+1
\end_layout

\begin_layout Plain Layout

			swap(A[i],A[j])
\end_layout

\begin_layout Plain Layout

			swap(B[i],B[j])
\end_layout

\begin_layout Plain Layout

	swap(A[i+1],A[r])
\end_layout

\begin_layout Plain Layout

	swap(B[i+1],B[r])
\end_layout

\begin_layout Plain Layout

	return i+1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Double-Pivot-Partition(A,B,p,r,i)
\end_layout

\begin_layout Plain Layout

	//A[i] is the entry you want to partition around
\end_layout

\begin_layout Plain Layout

	swap(A[i],A[r])
\end_layout

\begin_layout Plain Layout

	swap(B[i],B[r])
\end_layout

\begin_layout Plain Layout

	return Double-Partition(A,B,p,r)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Median-Closest(A,k)
\end_layout

\begin_layout Plain Layout

	//the actual median, not just the index
\end_layout

\begin_layout Plain Layout

	m = Select-Index(A,0,A.size-1,floor((A.size-1)/2))
\end_layout

\begin_layout Plain Layout

	B = A
\end_layout

\begin_layout Plain Layout

	for j=1 to A.size-1
\end_layout

\begin_layout Plain Layout

		A[j] = A[j]-A[m]
\end_layout

\begin_layout Plain Layout

	//
\end_layout

\begin_layout Plain Layout

	l = Select-Index(A,0,A.size-1,k)
\end_layout

\begin_layout Plain Layout

	//return will be k because l is index of kth OS
\end_layout

\begin_layout Plain Layout

	//and so it will be placed in the kth position.
\end_layout

\begin_layout Plain Layout

	Double-Pivot-Partition(A,B,0,l)
\end_layout

\begin_layout Plain Layout

	return B[0..k]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[9.3-8]
\end_layout

\end_inset

Let 
\begin_inset Formula $a_{m}=A[\lceil A.\text{size}/2\rceil]$
\end_inset

 and 
\begin_inset Formula $b_{m}=B[\lceil B.\text{size}/2\rceil]$
\end_inset

 the medians of each array.
 Let 
\begin_inset Formula $c_{i}<c_{i+1}$
\end_inset

 be the sorted elements in 
\begin_inset Formula $A\cup B$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 be the median of the 
\begin_inset Formula $\{c_{i}\}$
\end_inset

, i.e.
 
\begin_inset Formula $A\cup B$
\end_inset

.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Lemma:
\series default
 In 
\begin_inset Formula $A\cup B$
\end_inset

 it's the case that 
\begin_inset Formula $a_{b}\leq m\leq b_{m}$
\end_inset

, that in the final arrangement of elements the median of both arrays is
 between (or equal to one or the other other both of) the medians of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Proof: 
\series default
If 
\begin_inset Formula $a_{m}=b_{m}$
\end_inset

 then return then clearly the median of 
\begin_inset Formula $A\cup B=a_{m}=b_{m}$
\end_inset

.
 Hence without loss of generality assume 
\begin_inset Formula $a_{m}\neq b_{m}$
\end_inset

 and 
\begin_inset Formula $a_{m}<b_{m}$
\end_inset

.
 The quantity of 
\begin_inset Formula $c_{i}$
\end_inset

 such that 
\begin_inset Formula $c_{i}\leq a_{m}$
\end_inset

 is at most 
\begin_inset Formula $\lceil A.\text{size}/2\rceil-1+\lceil B.\text{size}/2\rceil-1$
\end_inset

, (saturating if 
\begin_inset Formula $a_{m}=b_{m}$
\end_inset

).
 These are all of the elements in 
\begin_inset Formula $A\le a_{m}$
\end_inset

 unioned with all of the elements in 
\begin_inset Formula $B\leq a_{m}.$
\end_inset

 Similarly there are at most 
\begin_inset Formula $\lceil A.\text{size}/2\rceil-1+\lceil B.\text{size}/2\rceil-1$
\end_inset

 such that 
\begin_inset Formula $c_{j}\geq b_{m}$
\end_inset

.
 Furthermore since 
\begin_inset Formula $a_{m}<b_{m}$
\end_inset

 there are at most 
\begin_inset Formula $\lceil A.\text{size}/2\rceil-1+\lceil B.\text{size}/2\rceil$
\end_inset

 elements in 
\begin_inset Formula $A\cup B$
\end_inset

 such that 
\begin_inset Formula $c_{i}\ge a_{m}$
\end_inset

 and similarly at most 
\begin_inset Formula $\lceil A.\text{size}/2\rceil-1+\lceil B.\text{size}/2\rceil$
\end_inset

 elements such that 
\begin_inset Formula $c_{j}\leq b_{m}$
\end_inset

.
 But the median 
\begin_inset Formula $m$
\end_inset

 is the element such that there are exactly 
\begin_inset Formula $\lceil A\cup B.\text{size}/2\rceil-1=\lceil A.\text{size}/2\rceil+\lceil B.\text{size}/2\rceil+1$
\end_inset

 elements less than it and 
\begin_inset Formula $\lceil A\cup B.\text{size}/2\rceil-1=\lceil A.\text{size}/2\rceil+\lceil B.\text{size}/2\rceil+1$
\end_inset

 greater than it.
 Therefore 
\begin_inset Formula $a_{m}\leq m\leq b_{m}$
\end_inset

.
 
\begin_inset Formula $\blacksmiley$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

To compute the median of 
\begin_inset Formula $A\cup B$
\end_inset

 compute 
\begin_inset Formula $a_{m}=A[\lceil A.\text{size}/2\rceil]$
\end_inset

 and 
\begin_inset Formula $b_{m}=B[\lceil B.\text{size}/2\rceil]$
\end_inset

 the medians of each array in constant time.
 If 
\begin_inset Formula $a_{m}=b_{m}$
\end_inset

 return 
\begin_inset Formula $a_{m}$
\end_inset

.
 Otherwise without loss of generality we assume 
\begin_inset Formula $a_{m}<b_{m}$
\end_inset

.
 Then compute the rank 
\begin_inset Formula $r_{a}$
\end_inset

 of 
\begin_inset Formula $a_{m}$
\end_inset

 in 
\begin_inset Formula $B$
\end_inset

 by performing a binary search for 
\begin_inset Formula $a_{m}$
\end_inset

 and returning the index of the last element checked plus one (if 
\begin_inset Formula $a_{m}\in B$
\end_inset

 this ranks 
\begin_inset Formula $a_{m}$
\end_inset

 ahead of its repetitions).
 Similarly compute the rank 
\begin_inset Formula $r_{b}$
\end_inset

 of 
\begin_inset Formula $b_{m}\in A$
\end_inset

.
 Then let all 
\begin_inset Formula $S_{b}$
\end_inset

 be all of the elements between 
\begin_inset Formula $r_{a}$
\end_inset

 and 
\begin_inset Formula $b_{m}$
\end_inset

 in 
\begin_inset Formula $B$
\end_inset

 are a subset the of elements that appear between 
\begin_inset Formula $a_{m}$
\end_inset

 in 
\begin_inset Formula $b_{m}$
\end_inset

 in 
\begin_inset Formula $A\cup B$
\end_inset

 and likewise for 
\begin_inset Formula $S_{b}$
\end_inset

 all of the elements between 
\begin_inset Formula $r_{b}$
\end_inset

 and 
\begin_inset Formula $a_{m}$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

.
 Finally by the Lemma above we know that the median 
\begin_inset Formula $m\in S_{a}\cup S_{b}$
\end_inset

 and since each of 
\begin_inset Formula $S_{a}$
\end_inset

and 
\begin_inset Formula $S_{b}$
\end_inset

 are already sorted we can recurse into them.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[10-1]
\end_layout

\end_inset

The complexities:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{p{3cm}p{1.25cm}p{1.25cm}p{1.25cm}p{1.25cm}}
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

Operation & unsorted, singly linked & sorted, singly linked & unsorted,
 doubly linked & sorted, doubly linked 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout


\backslash
hline  
\end_layout

\begin_layout Plain Layout

Search$(L,k)$  & $O(n)$ & $O(n)$ & $O(n)$ & $O(n)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Insert$(L,x)$ & $O(1)$ & $O(n)$ & $O(1)$ & $O(n)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Delete$(L,x)$ & $O(1)$ & $O(1)$ & $O(1)$ & $O(1)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Successor$(L,x)$ & $O(n)$ & $O(1)$ & $O(n)$ & $O(1)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor$(L,x)$ & $O(n)$ & $O(n)$ & $O(n)$ & $O(1)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Minimum$(L)$ & $O(n)$ & $O(1)$ & $O(n)$ & $O(1)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Maximum$(L)$ & $O(n)$ & $O(n)$ & $O(n)$ & $O(1)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[12.2-5]
\end_layout

\end_inset

Proof by contradiction.
 Let 
\begin_inset Formula $X$
\end_inset

 be the node in question and 
\begin_inset Formula $S$
\end_inset

 be the successor of node 
\begin_inset Formula $X$
\end_inset

.
 Assume 
\begin_inset Formula $S$
\end_inset

 has a left child 
\begin_inset Formula $S.left$
\end_inset

.
 But the successor of 
\begin_inset Formula $X$
\end_inset

 must be in the right subtree of 
\begin_inset Formula $X$
\end_inset

 and hence the 
\begin_inset Formula $S.left$
\end_inset

 is simultaneously less than 
\begin_inset Formula $S$
\end_inset

, by the binary search tree property (because it's the left child of 
\begin_inset Formula $S$
\end_inset

), and greater than 
\begin_inset Formula $X$
\end_inset

 (because it's in the right subtree of 
\begin_inset Formula $X$
\end_inset

).
 But then 
\begin_inset Formula $S$
\end_inset

 is not the successor.
 For predecessor let 
\begin_inset Formula $P$
\end_inset

 be the predecessor of 
\begin_inset Formula $X.$
\end_inset

 Assume 
\begin_inset Formula $P$
\end_inset

 has a right child 
\begin_inset Formula $P.right$
\end_inset

.
 But the predecessor of 
\begin_inset Formula $X$
\end_inset

 must be in the left subtree of 
\begin_inset Formula $X$
\end_inset

 and hence the 
\begin_inset Formula $P.right$
\end_inset

 is simultaneously greater than 
\begin_inset Formula $P$
\end_inset

, by the binary search tree property (because it's the right child of 
\begin_inset Formula $P$
\end_inset

), and less than 
\begin_inset Formula $X$
\end_inset

 (because it's in the left subtree of 
\begin_inset Formula $X$
\end_inset

).
 But then 
\begin_inset Formula $P$
\end_inset

 is not the predecessor.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[12.3-4]
\end_layout

\end_inset

 Deletion is not commutative.
 Counterexample:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikzset{every tree node/.style={minimum width=2em,draw,circle},
\end_layout

\begin_layout Plain Layout

         blank/.style={draw=none},
\end_layout

\begin_layout Plain Layout

         edge from parent/.style=
\end_layout

\begin_layout Plain Layout

         {draw, edge from parent path={(
\backslash
tikzparentnode) -- (
\backslash
tikzchildnode)}},
\end_layout

\begin_layout Plain Layout

         level distance=1.5cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Tree [.a
\end_layout

\begin_layout Plain Layout

         [.b ]
\end_layout

\begin_layout Plain Layout

	     [.c
\end_layout

\begin_layout Plain Layout

		
\backslash
edge[]; {d}
\end_layout

\begin_layout Plain Layout

         
\backslash
edge[blank]; 
\backslash
node[blank]{};		 
\end_layout

\begin_layout Plain Layout

    ]
\end_layout

\begin_layout Plain Layout

] 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Formula $\underrightarrow{\text{delete b}}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every tree node/.style={minimum width=2em,draw,circle},
\end_layout

\begin_layout Plain Layout

         blank/.style={draw=none},
\end_layout

\begin_layout Plain Layout

         edge from parent/.style=
\end_layout

\begin_layout Plain Layout

         {draw, edge from parent path={(
\backslash
tikzparentnode) -- (
\backslash
tikzchildnode)}},
\end_layout

\begin_layout Plain Layout

         level distance=1.5cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Tree [.a
\end_layout

\begin_layout Plain Layout

         
\backslash
edge[blank]; 
\backslash
node[blank]{};
\end_layout

\begin_layout Plain Layout

	     [.c
\end_layout

\begin_layout Plain Layout

		 
\backslash
edge[]; {d}
\end_layout

\begin_layout Plain Layout

         
\backslash
edge[blank]; 
\backslash
node[blank]{};		 
\end_layout

\begin_layout Plain Layout

    ]
\end_layout

\begin_layout Plain Layout

] 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Formula $\underrightarrow{\text{delete a}}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every tree node/.style={minimum width=2em,draw,circle},
\end_layout

\begin_layout Plain Layout

         blank/.style={draw=none},
\end_layout

\begin_layout Plain Layout

         edge from parent/.style=
\end_layout

\begin_layout Plain Layout

         {draw, edge from parent path={(
\backslash
tikzparentnode) -- (
\backslash
tikzchildnode)}},
\end_layout

\begin_layout Plain Layout

         level distance=1.5cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Tree [.c
\end_layout

\begin_layout Plain Layout

		 
\backslash
edge[]; {d}
\end_layout

\begin_layout Plain Layout

         
\backslash
edge[blank]; 
\backslash
node[blank]{};		 
\end_layout

\begin_layout Plain Layout

    ]
\end_layout

\begin_layout Plain Layout

] 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikzset{every tree node/.style={minimum width=2em,draw,circle},
\end_layout

\begin_layout Plain Layout

         blank/.style={draw=none},
\end_layout

\begin_layout Plain Layout

         edge from parent/.style=
\end_layout

\begin_layout Plain Layout

         {draw, edge from parent path={(
\backslash
tikzparentnode) -- (
\backslash
tikzchildnode)}},
\end_layout

\begin_layout Plain Layout

         level distance=1.5cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Tree [.a
\end_layout

\begin_layout Plain Layout

         [.b ]
\end_layout

\begin_layout Plain Layout

	     [.c
\end_layout

\begin_layout Plain Layout

		
\backslash
edge[]; {d}
\end_layout

\begin_layout Plain Layout

         
\backslash
edge[blank]; 
\backslash
node[blank]{};		 
\end_layout

\begin_layout Plain Layout

    ]
\end_layout

\begin_layout Plain Layout

] 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Formula $\underrightarrow{\text{delete a}}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every tree node/.style={minimum width=2em,draw,circle},
\end_layout

\begin_layout Plain Layout

         blank/.style={draw=none},
\end_layout

\begin_layout Plain Layout

         edge from parent/.style=
\end_layout

\begin_layout Plain Layout

         {draw, edge from parent path={(
\backslash
tikzparentnode) -- (
\backslash
tikzchildnode)}},
\end_layout

\begin_layout Plain Layout

         level distance=1.5cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Tree [.d
\end_layout

\begin_layout Plain Layout

         [.b ]
\end_layout

\begin_layout Plain Layout

	     [.c ]
\end_layout

\begin_layout Plain Layout

] 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Formula $\underrightarrow{\text{delete b}}$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzset{every tree node/.style={minimum width=2em,draw,circle},
\end_layout

\begin_layout Plain Layout

         blank/.style={draw=none},
\end_layout

\begin_layout Plain Layout

         edge from parent/.style=
\end_layout

\begin_layout Plain Layout

         {draw, edge from parent path={(
\backslash
tikzparentnode) -- (
\backslash
tikzchildnode)}},
\end_layout

\begin_layout Plain Layout

         level distance=1.5cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
Tree [.d
\end_layout

\begin_layout Plain Layout

		 
\backslash
edge[blank]; 
\backslash
node[blank]{};
\end_layout

\begin_layout Plain Layout

         [.c ]	     	
\end_layout

\begin_layout Plain Layout

] 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[12.3-5]
\end_layout

\end_inset

Search is not affected because it doesn't use the parent pointer in any
 of the nodes.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Insertion isn't affected either except that now instead 
\begin_inset Formula $z.p=y$
\end_inset

 we need to set 
\begin_inset Formula $z.succ$
\end_inset

 to something appropriate.
 If 
\begin_inset Formula $z$
\end_inset

 is inserted as a left child then its successor is its parent 
\begin_inset Formula $p$
\end_inset

, since 
\begin_inset Formula $p$
\end_inset

 is certainly greater and if there were a node 
\begin_inset Formula $p'<p$
\end_inset

 and 
\begin_inset Formula $z<p'$
\end_inset

 then 
\begin_inset Formula $z$
\end_inset

 would have been inserted as the left child of 
\begin_inset Formula $p'$
\end_inset

.
 If 
\begin_inset Formula $z$
\end_inset

 is inserted as a right child then its successor is the successor of its
 parent 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

's successor is now 
\begin_inset Formula $z$
\end_inset

, since being inserted as a right child implies 
\begin_inset Formula $p<z$
\end_inset

 therefore 
\begin_inset Formula $z$
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

closer
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Formula $p$
\end_inset

's successor than 
\begin_inset Formula $p$
\end_inset

 and there are no other elements between 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Hence 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Tree-Insert(T,z)
\end_layout

\begin_layout Plain Layout

	y = NIL
\end_layout

\begin_layout Plain Layout

	x = T.root
\end_layout

\begin_layout Plain Layout

	while x != NIL
\end_layout

\begin_layout Plain Layout

		y = x
\end_layout

\begin_layout Plain Layout

		if z.key < x.key
\end_layout

\begin_layout Plain Layout

			x = x.left
\end_layout

\begin_layout Plain Layout

		else
\end_layout

\begin_layout Plain Layout

			x = x.right
\end_layout

\begin_layout Plain Layout

	if y == NIL
\end_layout

\begin_layout Plain Layout

		T.root = z
\end_layout

\begin_layout Plain Layout

		z.succ = NIL
\end_layout

\begin_layout Plain Layout

	else if z.key < y.key
\end_layout

\begin_layout Plain Layout

		y.left = z
\end_layout

\begin_layout Plain Layout

		z.succ = y
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		y.right = z
\end_layout

\begin_layout Plain Layout

		z.succ = y.succ
\end_layout

\begin_layout Plain Layout

		y.succ = z
\end_layout

\end_inset

Running time of Tree-Insert is still 
\begin_inset Formula $O(\lg n)$
\end_inset

 since we've only added constant time operations to it.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

In order to implement Delete, which calls Transpant (which makes heavy use
 of parent pointers), we implement another auxilliary routine Parent(T,u).
 The easiest way to find 
\begin_inset Formula $u'$
\end_inset

s parent is to search for 
\begin_inset Formula $u$
\end_inset

 while keeping a trailing pointer 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Parent(T,u)
\end_layout

\begin_layout Plain Layout

	y = NIL
\end_layout

\begin_layout Plain Layout

	x = T.root
\end_layout

\begin_layout Plain Layout

	while x != u
\end_layout

\begin_layout Plain Layout

		y = x
\end_layout

\begin_layout Plain Layout

		if u.key < x.key
\end_layout

\begin_layout Plain Layout

			x = x.left
\end_layout

\begin_layout Plain Layout

		else 
\end_layout

\begin_layout Plain Layout

			x = x.right
\end_layout

\begin_layout Plain Layout

	return y
\end_layout

\end_inset

Parent has the same structure as Iterative-Tree-Search except that it matches
 on node rather than key (in case there are several nodes with the same
 value) and hence is correct and runs in 
\begin_inset Formula $O(\lg n)$
\end_inset

 time.
 Then we implment transplant with calls to Parent wherever there's a parent
 pointer being referenced
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Transplant(T,u,v)
\end_layout

\begin_layout Plain Layout

	uParent = Parent(T,u)
\end_layout

\begin_layout Plain Layout

	if uParent == NIL
\end_layout

\begin_layout Plain Layout

		T.root = V
\end_layout

\begin_layout Plain Layout

	else if u == uParent.left
\end_layout

\begin_layout Plain Layout

		uParent.left = v
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		uParent.right = v
\end_layout

\begin_layout Plain Layout

	if v != NIL
\end_layout

\begin_layout Plain Layout

		vParent = Parent(T,v)
\end_layout

\begin_layout Plain Layout

		vParent = uParent
\end_layout

\end_inset

Because the only thing changed is how parent pointers are found Transplant
 is correct for the same reason Transplant from CLRS is correct.
 Furthermore Transplant(T,u,v) runs in at most 
\begin_inset Formula $O(\lg n)$
\end_inset

 time since it makes at most 2 calls to Parent.
 And similarly for Tree-Delete
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Tree-Delete(T,z)
\end_layout

\begin_layout Plain Layout

	if z.left == NIL
\end_layout

\begin_layout Plain Layout

		Transplant(T,z,z.right)
\end_layout

\begin_layout Plain Layout

	else if z.right == NIL
\end_layout

\begin_layout Plain Layout

		Transplant(T,z,z.left)
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		y = z.succ
\end_layout

\begin_layout Plain Layout

		yParent = Parent(T,y)
\end_layout

\begin_layout Plain Layout

		if yParent != z
\end_layout

\begin_layout Plain Layout

			Transplant(T,y,y.right)
\end_layout

\begin_layout Plain Layout

			y.right = z.right
\end_layout

\begin_layout Plain Layout

			yRightParent = Parent(T,y.right)
\end_layout

\begin_layout Plain Layout

			yRightParent = y
\end_layout

\begin_layout Plain Layout

		Transplant(T,z,y)
\end_layout

\begin_layout Plain Layout

		y.left = z.left
\end_layout

\begin_layout Plain Layout

		yLeftParent = Parent(T,y.left)
\end_layout

\begin_layout Plain Layout

		yLeftParent = y
\end_layout

\end_inset

 Tree-Delete has the same structure as Tree-Delete from CLRS and hence is
 correct and runs in at most 
\begin_inset Formula $O(\lg n)$
\end_inset

 time since it makes at most 3 calls to Transplant and 3 calls to Parent,
 each of which are run in at most 
\begin_inset Formula $O(\lg n)$
\end_inset

 time themselves.
\end_layout

\end_body
\end_document
