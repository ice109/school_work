#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble

%
\usepackage{mathdots}
\usepackage{listings}
\usepackage{tikz}
\usepackage{pgf}
\usepackage{tikz-qtree}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{amsfonts}\usepackage{nopageno}%%%  The following few lines affect the margin sizes. 
\addtolength{\topmargin}{-.5in}
\setlength{\textwidth}{6in}       
\setlength{\oddsidemargin}{.25in}              
\setlength{\evensidemargin}{.25in}         
  
\setlength{\textheight}{9in}
\renewcommand{\baselinestretch}{1}
\reversemarginpar   

\lstset{
numbers=left
}


%
%
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=single"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
COT5405 Homework 1 Solutions
\end_layout

\begin_layout Author
Maksim Levental
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[2.3-4]
\end_layout

\end_inset

For this 
\begin_inset Quotes eld
\end_inset

recursive
\begin_inset Quotes erd
\end_inset

 implementation of insertion sort 
\begin_inset Formula $T(n)=T(n-1)+O(n).$
\end_inset

 The inductive hypothesis is 
\begin_inset Formula $T(m)\leq c_{1}m^{2}$
\end_inset

 for all 
\begin_inset Formula $m<n$
\end_inset

.
 Then
\begin_inset Formula 
\begin{align*}
T(n) & =T(n-1)+c_{2}n\\
 & \leq c_{1}(n-1)^{2}+c_{2}n\\
 & =c_{1}n^{2}-2c_{1}n+2c_{1}+c_{2}n & \text{choose }c_{1}\text{ s.t. }2c_{1}n\geq c_{2}n+2c_{1}\\
 & \leq c_{1}n^{2}\\
T(n) & =O(n^{2})
\end{align*}

\end_inset

Furthermore we choose the base case such that 
\begin_inset Formula $2c_{1}n\geq c_{2}n+2c_{1}$
\end_inset

 is satisfied.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[2.3-5]
\end_layout

\end_inset

The pseudo-code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Binary-Search(A,p,r,x)
\end_layout

\begin_layout Plain Layout

  if p==r and A[p] != x
\end_layout

\begin_layout Plain Layout

    return -1
\end_layout

\begin_layout Plain Layout

  pivot = floor((p-r+1)/2)
\end_layout

\begin_layout Plain Layout

  else if A[pivot] == x
\end_layout

\begin_layout Plain Layout

    return pivot
\end_layout

\begin_layout Plain Layout

  else if A[pivot] < x
\end_layout

\begin_layout Plain Layout

    Binary-Search(A,pivot+1,r,x)
\end_layout

\begin_layout Plain Layout

  else 
\end_layout

\begin_layout Plain Layout

    Binary-Search(p,pivot-1,x) 
\end_layout

\begin_layout Plain Layout

    //only if A[floor(A.length/2)] > x
\end_layout

\begin_layout Plain Layout

    //since first branch checks ==
\end_layout

\begin_layout Plain Layout

    //so no need to include element
\end_layout

\begin_layout Plain Layout

    //A[0:floor(A.length/2)]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Binary-Search(A,x) returns the index of a match or -1 if the search fails.
 The recursion relation for the running time is 
\begin_inset Formula $T(n)=T(n/2)+O(1).$
\end_inset

 Since 
\begin_inset Formula $f(n)=1=\Theta\bigg(n^{log_{2}1}\bigg)$
\end_inset

 the master theorem immediately yields 
\begin_inset Formula $T(n)=\Theta(n^{log_{2}1}\lg n)=\Theta(n^{0}\lg n)=\Theta(\lg n)$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[2.3-6]
\end_layout

\end_inset

This in fact doesn't work but I didn't realize it until I finished the analysis.
 Read the comment at the end.
 Reimagine the array in which all the elements are stored as linked-list
 and rewrite Binary-Search to return a pointer to the last node recursed
 to.
 Then the value to be inserted by Insertion-Sort-Binary-Search(A) inserts
 a node in the linked list whose child is the last node returned by Binary-Searc
h and whose parent is the parent of the node return by Binary-Search-LL.
 That is 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Binary-Search-LL(A,p,r,x)
\end_layout

\begin_layout Plain Layout

  //linked-list overloads [] operator
\end_layout

\begin_layout Plain Layout

  pivot = floor((p-r+1)/2)
\end_layout

\begin_layout Plain Layout

  if p==r 
\end_layout

\begin_layout Plain Layout

    return pivot
\end_layout

\begin_layout Plain Layout

  else if A[pivot] == x
\end_layout

\begin_layout Plain Layout

    return pivot
\end_layout

\begin_layout Plain Layout

  else if A[pivot] < x
\end_layout

\begin_layout Plain Layout

    Binary-Search(A,pivot+1,r,x)
\end_layout

\begin_layout Plain Layout

  else 
\end_layout

\begin_layout Plain Layout

    Binary-Search(p,pivot-1,x) 
\end_layout

\end_inset

Then Insertion-Sort-Binary-Search(A) is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Insertion-Sort-Binary-Search(A)
\end_layout

\begin_layout Plain Layout

  for j=2..A.length
\end_layout

\begin_layout Plain Layout

    key=A[j]
\end_layout

\begin_layout Plain Layout

    pivot = Binary-Search-LL(A,0,j-1,key)
\end_layout

\begin_layout Plain Layout

    A.insert(key,pivot-1) //insert key just "behind" 
\end_layout

\begin_layout Plain Layout

                          //node returned by binary search  
\end_layout

\end_inset

Then 
\begin_inset Formula $T(n)=c_{1}n+c_{2}(n-1)+(n-1)\Theta(\lg n)+(n-1)g(n)$
\end_inset

.
 So the question of whether Insert-Sort-Binary-Search(A) is 
\begin_inset Formula $\Theta(n\lg n)$
\end_inset

 a matter of how long it takes to insert into 
\begin_inset Formula $A$
\end_inset

 implemented as a linked-list.
 From http://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html we
 see that ListIterator.add(E element) inserts in 
\begin_inset Formula $O(1)$
\end_inset

 so 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula 
\begin{align*}
T(n) & =c_{1}n+c_{2}(n-1)+(n-1)\Theta(\lg n)+(n-1)g(n)\\
 & =c_{1}n+c_{2}(n-1)+(n-1)\Theta(\lg n)+(n-1)O(1)\\
 & =(n-1)\Theta(\lg n)\\
 & =\Theta(n\lg n)
\end{align*}

\end_inset

The problem with this analysis is that linked-list 
\series bold
doesn't actually overload
\series default
 
\begin_inset Formula $[\,]$
\end_inset

 and so Binary-Search-LL(A,p,r,x) isn't possible.
 Therefore while the number 
\series bold
comparisons 
\series default
done by Insertion-Sort with a binary search finding the insertion point
 would be 
\begin_inset Formula $O(n\lg n)$
\end_inset

 the algorithm as a whole would still run in 
\begin_inset Formula $O(n^{2})$
\end_inset

 in the worst case because there would still be 
\begin_inset Formula $O(n^{2})$
\end_inset

 
\series bold
swaps
\series default
 that would need to be done in order to actually insert.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[2.4]
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
(2,1), (3,1), (8,1), (6,1), (8,6)
\end_layout

\begin_layout Enumerate
Reverse sorted, i.e.
 
\begin_inset Formula $\left\{ n,n-1,\cdots,1\right\} $
\end_inset

.
 The number of inversions is 
\begin_inset Formula $n-1$
\end_inset

 for 1 because there are 
\begin_inset Formula $n-1$
\end_inset

 elements in the array which are larger than 1 but preceed it in the array,
 
\begin_inset Formula $n-2$
\end_inset

 for 2 because there 
\begin_inset Formula $n-2$
\end_inset

 elements which are larger than 2 (exceptions are 2 and 1) but preceed it,
 and so on.
 So for 
\begin_inset Formula $i=1,2,\cdots,n$
\end_inset

 the number of inversions induced is 
\begin_inset Formula $n-i$
\end_inset

 .
 In sum 
\begin_inset Formula $\sum_{i=1}^{n}n-i=n\sum_{i=1}^{n}1-\sum_{i=1}^{n}i=n^{2}-\frac{{n(n+1)}}{2}=n^{2}-\frac{{(n^{2}+n)}}{2}=\frac{{n(n-1)}}{2}$
\end_inset


\end_layout

\begin_layout Enumerate
Call an inversion of type 
\begin_inset Formula $(j,i)$
\end_inset

 induced by an element 
\begin_inset Formula $A[j]$
\end_inset

 if 
\begin_inset Formula $j$
\end_inset

 is such that 
\begin_inset Formula $A[j]<A[i]$
\end_inset

 and 
\begin_inset Formula $i<j$
\end_inset

 and let 
\begin_inset Formula $|(j,i)|$
\end_inset

 be the number of such inversions.
 Then 
\begin_inset Formula $|(j,i)|$
\end_inset

 is the number of swaps that will have to be performed on element 
\begin_inset Formula $A[j]$
\end_inset

 before it is in its proper position.
 To see that this is the case note that all 
\begin_inset Formula $(j,i)$
\end_inset

 inversions persist through the sorting process, up until 
\begin_inset Formula $A[j]$
\end_inset

 is sorted, since for all 
\begin_inset Formula $i<j$
\end_inset

 element 
\begin_inset Formula $A[i]$
\end_inset

 will be inserted into the sorted portion of the array prior to 
\begin_inset Formula $A[j].$
\end_inset

 Therefore upon inserting 
\begin_inset Formula $A[j]$
\end_inset

 there will still be 
\begin_inset Formula $|(j,i)|$
\end_inset

 inversions and therefore 
\begin_inset Formula $|(j,i)|$
\end_inset

 swaps.
 Consequently 
\begin_inset Formula $\sum_{j}|(j,i)|$
\end_inset

 the total number of inversions in the array is the total number of swaps
 performed by insertion sort, i.e.
 directly proportional insertion sort's running time.
\end_layout

\begin_layout Enumerate
Modify merge sort such that when the function returns from the two recursive
 calls, when the 
\begin_inset Quotes eld
\end_inset

merging
\begin_inset Quotes erd
\end_inset

 is done, it counts the number of elements in the 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

 array each time an element is chosen from the front of the 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

 array ( after comparison between the leading elements of both arrays).
 The quantity of elements in the 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

 array each time an element from the front of the right array is chosen
 is by definition the number of elements in the original array that were
 greater than that chosen element and yet preceeded it.
 Furthermore there is no double counting because once a merge happens 2
 elements in the merged array are never compared again.
 Take for example the array 
\begin_inset Formula $\mbox{\left[8,7,6,5,4,3,2,1\right]}$
\end_inset

 and suppose the recursion bottoms out at 4 elements.
 Then the first recursion returns 
\begin_inset Formula $\left[5,6,7,8\right]$
\end_inset

 and 
\begin_inset Formula $\left[1,2,3,4\right]$
\end_inset

.
 The merging then selects each of the four elements from the 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

 array 
\begin_inset Formula $\left[1,2,3,4\right]$
\end_inset

 since each of the elements in the 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

 array 
\begin_inset Formula $\left[5,6,7,8\right]$
\end_inset

 is greater than each in the 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

.
 Manifestly there are 4 inversions per element in the 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

 array, 1 for each element in the 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

 array, and so the total is 16.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[3-1]
\end_layout

\end_inset

Lemma: if 
\begin_inset Formula $k,d\in\mathbb{N}$
\end_inset

 and 
\begin_inset Formula $k\leq d$
\end_inset

 then 
\begin_inset Formula $n^{k}\leq n^{d}.$
\end_inset

 
\begin_inset Newline newline
\end_inset

Proof: 
\begin_inset Formula $n^{k}/n^{d}=n^{k-d}=1/n^{d-k}\leq0$
\end_inset

 since 
\begin_inset Formula $k-d\leq0$
\end_inset

.
 
\begin_inset Newline newline
\end_inset

Corollary: if 
\begin_inset Formula $k,d\in\mathbb{N}$
\end_inset

 and 
\begin_inset Formula $k>d$
\end_inset

 then 
\begin_inset Formula $n^{k}>n^{d}.$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Let 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $p(n)=\sum_{i=0}^{d}a_{i}n^{i}$
\end_inset

 and 
\begin_inset Formula $c=\max\{a_{0},a_{1},\dots,a_{d}\}$
\end_inset

.
 Note that 
\begin_inset Formula $c\geq0$
\end_inset

 since otherwise all 
\begin_inset Formula $a_{i}<0$
\end_inset

 and therefore 
\begin_inset Formula $p(n)<0$
\end_inset

.
 Then for all 
\begin_inset Formula $i\in\{0,1,\dots,d\}$
\end_inset

 and for 
\begin_inset Formula $k\ge d$
\end_inset

 the lemma above implies 
\begin_inset Formula $cn^{k}\ge a_{i}n^{i}$
\end_inset

.
 Therefore 
\begin_inset Formula $\sum_{i=0}^{d}cn^{k}=c\dot{\cdot(d+1)\cdot n^{k}\ge\sum_{i=0}^{d}a_{i}n^{i}=p(n)}.$
\end_inset


\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Enumerate
Let 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $p(n)=a_{d}n^{d}+\sum_{i=0}^{d-1}a_{i}n^{i}$
\end_inset

.
 Then by part (a) 
\begin_inset Formula $\sum_{i=0}^{d-1}a_{i}n^{i}\in O(n^{d-1})$
\end_inset

 so there exists 
\begin_inset Formula $c_{1}$
\end_inset

 such that 
\begin_inset Formula $\sum_{i=0}^{d-1}a_{i}n^{i}\leq c_{1}n^{d-1}$
\end_inset

.
 Therefore 
\begin_inset Formula $p(n)\ge a_{d}n^{d}-c_{1}n^{d-1}.$
\end_inset

 Fix any 
\begin_inset Formula $\epsilon<a_{d}$
\end_inset

 and for 
\begin_inset Formula $n>c_{1}/\epsilon$
\end_inset

 
\begin_inset Formula 
\begin{align*}
p(n) & \geq(a_{d}-\epsilon)n^{d}+\epsilon n^{d}-c_{1}n^{d-1}\\
 & =(a_{d}-\epsilon)n^{d}+n^{d-1}(\epsilon n-c_{1})\\
 & \geq(a_{d}-\epsilon)n^{d}\\
 & \geq(a_{d}-\epsilon)n^{k} & \text{by the lemma}
\end{align*}

\end_inset

Hence if 
\begin_inset Formula $c_{2}=(a_{d}-\epsilon)$
\end_inset

 and 
\begin_inset Formula $n>c_{1}/\epsilon$
\end_inset

 then 
\begin_inset Formula $p(n)\geq c_{2}n^{k}$
\end_inset

 and therefore 
\begin_inset Formula $p(n)=\Omega(n^{k})$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
Let 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $p(n)=\sum_{i=0}^{d}a_{i}n^{i}$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 By part (a) 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
we have that for 
\begin_inset Formula $k=d$
\end_inset

 there exist 
\begin_inset Formula $c_{1}$
\end_inset

 and 
\begin_inset Formula $n_{0}$
\end_inset

 such that 
\begin_inset Formula $p(n)\leq c_{1}n^{k}$
\end_inset

.
 By part (b) we have that for 
\begin_inset Formula $k=d$
\end_inset

 there exist 
\begin_inset Formula $c_{2}$
\end_inset

 and 
\begin_inset Formula $n_{1}$
\end_inset

 such that 
\begin_inset Formula $p(n)\geq c_{2}n^{k}$
\end_inset

.
 Let 
\begin_inset Formula $n_{2}=\max\{n_{0},n_{1}\}$
\end_inset

 then for all 
\begin_inset Formula $n\geq n_{2}$
\end_inset

 we have that 
\begin_inset Formula $c_{2}n^{k}\leq p(n)\leq c_{1}n^{k}$
\end_inset

.
 Therefore 
\begin_inset Formula $p(n)=\Theta(n^{k})$
\end_inset

.
\end_layout

\begin_layout Enumerate
Let 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $p(n)=\sum_{i=0}^{d}a_{i}n^{i}$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 Part (a) guarantees there exist constants 
\begin_inset Formula $c_{1}$
\end_inset

 and 
\begin_inset Formula $n_{0}$
\end_inset

 such that for 
\begin_inset Formula $n_{0}\geq n$
\end_inset

 it's the case that 
\begin_inset Formula $p(n)\leq c_{1}n^{d}$
\end_inset

.
 Then for 
\begin_inset Formula $k>d$
\end_inset

 and any constant 
\begin_inset Formula $c_{2}$
\end_inset

 let 
\begin_inset Formula $n_{1}$
\end_inset

 be be such that 
\begin_inset Formula $n_{1}^{k-d}>c_{1}/c_{2}$
\end_inset

.
 Such an 
\begin_inset Formula $n_{1}$
\end_inset

 can be chosen since 
\begin_inset Formula $k-d>0\implies\exists n_{j}\text{ s.t. }n_{j}^{k-d}>c$
\end_inset

 for any constant 
\begin_inset Formula $c$
\end_inset

.
 Then 
\begin_inset Formula $c_{2}n_{1}^{k}-c_{1}n_{1}^{d}=n_{1}^{d}(c_{2}n_{1}^{k-d}-c_{1})>0$
\end_inset

.
 Finally let 
\begin_inset Formula $n_{3}=\max\{n_{0},n_{1}\}$
\end_inset

 and for all 
\begin_inset Formula $n\geq n_{3}$
\end_inset

 we have 
\begin_inset Formula $c_{2}n^{k}>c_{1}n^{d}\geq p(n)$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
The argument that worked for part (a) works here.
 For any 
\begin_inset Formula $c$
\end_inset

 let 
\begin_inset Formula $\epsilon=|a_{d}-c|$
\end_inset

 and 
\begin_inset Formula $n_{0}>c_{1}/\epsilon$
\end_inset

.
 If 
\begin_inset Formula $a_{d}>c$
\end_inset

 then there's no problem and the proof from part (b) works.
 Otherwise let 
\begin_inset Formula $n_{1}$
\end_inset

 be such that for 
\begin_inset Formula $n\geq n_{1}\implies n>\sqrt[d-k]{c/(a_{d}-\epsilon)}$
\end_inset

 then 
\begin_inset Formula 
\[
n>\sqrt[d-k]{\frac{c}{a_{d}-\epsilon}}\implies n^{d-k}>\frac{c}{a_{d}-\epsilon}\implies n^{d}>\frac{c}{a_{d}-\epsilon}n^{k}\implies(a_{d}-\epsilon)n^{d}>cn^{k}
\]

\end_inset

Therefore
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula 
\begin{align*}
p(n) & \geq(a_{d}-\epsilon)n^{d}+\epsilon n^{d}-c_{1}n^{d-1}\\
 & =(a_{d}-\epsilon)n^{d}+n^{d-1}(\epsilon n-c_{1})\\
 & \geq(a_{d}-\epsilon)n^{d}\\
 & >cn^{k}
\end{align*}

\end_inset

Hence 
\begin_inset Formula $p(n)=\omega(n^{k})$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[3.2]
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\end_layout

\end_inset

 Let 
\begin_inset Formula $a=2^{c}$
\end_inset

 for some 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $n=\lg m$
\end_inset

 then by (3.10) in CLRS we have that 
\begin_inset Formula 
\[
0=\lim_{n\rightarrow\infty}\frac{n^{b}}{a^{n}}=\lim_{\lg m\rightarrow\infty}\frac{(\lg m)^{b}}{(2^{c})^{\lg m}}
\]

\end_inset

and there for 
\begin_inset Formula $(\lg n)^{b}=o(n^{a})$
\end_inset

 for any 
\begin_inset Formula $a$
\end_inset

.
 And by the definitions of 
\begin_inset Formula $O(g(n))$
\end_inset

 and 
\begin_inset Formula $o(g(n))$
\end_inset

 we have that 
\begin_inset Formula $O(g(n))\implies o(g(n))$
\end_inset

 and so 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(\lg n)^{b}=O(n^{a})$
\end_inset

 .
 By exercise 
\family default
\series bold
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
3.1-7
\series default
 we have that 
\begin_inset Formula $(\lg n)^{b}\neq\omega(n^{a})$
\end_inset

 .
 To prove 
\series bold
3.1-7 
\series default
let 
\begin_inset Formula $f(n)=o(g(n))$
\end_inset

 .
 Then for 
\begin_inset Formula $c_{1}$
\end_inset

 there exists 
\begin_inset Formula $k_{1}$
\end_inset

 such that for all 
\begin_inset Formula $n\geq k$
\end_inset

 it is the case that 
\begin_inset Formula $f(n)\leq c_{1}g(n)$
\end_inset

.
 Since 
\begin_inset Formula $f(n)$
\end_inset

 and 
\begin_inset Formula $g(n)$
\end_inset

 are non-negative it's then true that 
\begin_inset Formula $f(n)\leq c_{1}g(n)<(c_{1}+1)g(n)$
\end_inset

 .
 Then for 
\begin_inset Formula $1/(c_{1}+1)$
\end_inset

 there is no 
\begin_inset Formula $k_{2}$
\end_inset

 such that 
\begin_inset Formula $g(n)\leq\frac{1}{c_{1+1}}f(n)$
\end_inset

 and hence 
\begin_inset Formula $g(n)\ne\omega(f(n))$
\end_inset

.
 A similar argument shows that if there existed constants 
\begin_inset Formula $c_{3}$
\end_inset

 and 
\begin_inset Formula $k_{3}$
\end_inset

 such that 
\begin_inset Formula $g(n)\leq c_{3}f(n)$
\end_inset

 for all 
\begin_inset Formula $n\geq k_{3}$
\end_inset

 then 
\begin_inset Formula $f(n)$
\end_inset

 would be equal to 
\begin_inset Formula $o(g(n))$
\end_inset

 and so 
\begin_inset Formula $f(n)$
\end_inset

 can't be 
\begin_inset Formula $\Omega(g(n))$
\end_inset

 and therefore neither 
\begin_inset Formula $\Theta(g(n))$
\end_inset

.
\end_layout

\begin_layout Enumerate
Again by (3.10) in CLRS we have that 
\begin_inset Formula $n^{k}=o(c^{n})$
\end_inset

 and the rest follows similarly to part (a)
\end_layout

\begin_layout Enumerate
Since 
\begin_inset Formula $n^{\sin n}$
\end_inset

 oscillates 
\begin_inset Formula $\frac{1}{n}\leq n^{\sin n}\leq n$
\end_inset

 it is none of 
\begin_inset Formula $O,o,\Omega,\omega,\Theta$
\end_inset

 because for any fixed 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 there will be 
\begin_inset Formula $n_{1},n_{2}\ge k$
\end_inset

 such that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $n_{1}^{\sin n_{1}}<\sqrt{n_{1}}$
\end_inset

 and 
\begin_inset Formula $\sqrt{n_{2}}<n_{2}^{\sin n_{2}}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 .
\end_layout

\begin_layout Enumerate
Taking the 
\begin_inset Formula $\log_{2}$
\end_inset

 of both (
\begin_inset Formula $\log$
\end_inset

 is monotonic increasing) we have the 
\begin_inset Formula $A=n$
\end_inset

 and 
\begin_inset Formula $B=n/2$
\end_inset

 .
 Clearly then 
\begin_inset Formula $2^{n}=O(2^{n/2})$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $2^{n}=\Omega(2^{n/2})$
\end_inset

 and therefore 
\begin_inset Formula $2^{n}=\Theta(2^{n/2})$
\end_inset

, but neither 
\begin_inset Formula $2^{n}=o(2^{n/2})$
\end_inset

 nor 
\begin_inset Formula $2^{n}=\omega(2^{n/2})$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\end_layout

\begin_layout Enumerate
By (3.15) in CLRS we have 
\begin_inset Formula $n^{\lg c}=c^{\lg n}$
\end_inset

 and so clearly then 
\begin_inset Formula $n^{\lg c}=O(c^{\lg n})$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $n^{\lg c}=\Omega(c^{\lg n})$
\end_inset

 and therefore 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $n^{\lg c}=\Theta(c^{\lg n})$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
, but neither 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $n^{\lg c}=o(c^{\lg n})$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 nor 
\begin_inset Formula $n^{\lg c}=\omega(c^{\lg n})$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 .
\end_layout

\begin_layout Enumerate
By exercise 
\series bold
3.2-3
\series default
 we have that 
\begin_inset Formula $n!=o(n^{n})$
\end_inset

 and therefore 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $n!=O(n^{n})$
\end_inset

 and by problem 
\begin_inset Formula $ $
\end_inset


\family default
\series bold
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
3.4-c 
\series default
we have that 
\begin_inset Formula $\lg(n!)=O(\lg(n^{n}))$
\end_inset

.
 In summary
\begin_inset Formula 
\[
\begin{array}{ccccccc}
A & B & O & o & \Omega & \omega & \Theta\\
(\text{lg}n)^{k} & n^{\epsilon} & yes & yes & no & no & no\\
n^{k} & c^{n} & yes & yes & no & no & no\\
\sqrt{n} & n^{\text{sin}n} & no & no & no & no & no\\
2^{n} & 2^{n/2} & yes & yes & yes & no & no\\
n^{\text{lg}c} & c^{\text{lg}n} & yes & yes & yes & no & no\\
\text{lg}(n!) & \text{lg}(n^{n}) & yes & ? & ? & ? & ?
\end{array}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[4.5]
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\noindent
\align block
Let 
\begin_inset Formula $n_{b}$
\end_inset

 be the number of bad chips and 
\begin_inset Formula $n_{g}$
\end_inset

 be the number of good chips.
 Without loss of generality assume there is only one good chip, 
\begin_inset Formula $n_{g}=1$
\end_inset

.
 Then picking there are 
\begin_inset Formula $1+n_{b}$
\end_inset

 choices chip is in fact the good one, i.e.
 any algorithm must distinguish between 
\begin_inset Formula $1+n_{b}$
\end_inset

 different cases.
 Suppose that all bad chips always report any other chip to be 
\begin_inset Quotes eld
\end_inset

bad
\begin_inset Quotes erd
\end_inset

.
 Then there is not information to distinguish between the 
\begin_inset Formula $1+n_{b}$
\end_inset

 different cases since the good chip as well always report 
\begin_inset Quotes eld
\end_inset

bad
\begin_inset Quotes erd
\end_inset

 (so there is only one bit of information).
\end_layout

\begin_layout Enumerate
Divide the set of chips into pairs.
 If there is an odd number of chips set the odd one aside.
 Perform the comparisons within each pair.
 If both chips in a pair report the other chip 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 then keep either one, otherwise discard both.
 Repeat the process.
 Let 
\begin_inset Formula $n_{b_{j}}$
\end_inset

 and 
\begin_inset Formula $n_{g_{j}}$
\end_inset

 be the number of bad chips and good chips left after the 
\begin_inset Formula $j$
\end_inset

th iteration of the algorithm.
 At any step in the recursive process a majority of the remaining chips
 will be good since the only way to discard a good chip is if it is paired
 with a bad chip and therefore discarding both preserves 
\begin_inset Formula $n_{g_{j}}/n_{b_{j}}>1$
\end_inset

 for all 
\begin_inset Formula $j$
\end_inset

.
 The recursion bottoms out and the invariant is preserved so the last chip
 left must be good.
 The halves the problem size since half the chips are discarded at every
 step.
\end_layout

\begin_layout Enumerate
By part one we can find at least one good chip in 
\begin_inset Formula $T(n)\approx T(n/2)+O(n)$
\end_inset

.
 Let 
\begin_inset Formula $c_{1}$
\end_inset

 be such that 
\begin_inset Formula $T(n)\leq T(n/2)+c_{1}n$
\end_inset

 and 
\begin_inset Formula $c_{2}$
\end_inset

 such that 
\begin_inset Formula $c_{2}>2c_{1}$
\end_inset

.
 Then the inductive hypothesis is 
\begin_inset Formula $T(n)\leq c_{2}n$
\end_inset

.
 Then we have 
\begin_inset Formula 
\[
T(n)\leq\frac{c_{2}n}{2}+c_{1}n=c_{2}n-n\bigg(\frac{c_{2}}{2}-a\bigg)\leq c_{2}n
\]

\end_inset

Hence it takes 
\begin_inset Formula $T(n)=O(n)$
\end_inset

 to find one good chip, which you can then use to sort the rest of 
\begin_inset Formula $n-1$
\end_inset

 chips using 
\begin_inset Formula $n-1$
\end_inset

 comparisons, stopping early if you've found all of the good chips.
 Hence total time is 
\begin_inset Formula $\Theta(n)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[4.7]
\end_layout

\end_inset


\begin_inset Formula $\begin{array}{ccccccc}
\\
\\
\\
\\
\\
\\
\\
\end{array}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Take the matrix 
\begin_inset Formula $A=\begin{bmatrix}a & b & c\\
d & e & f\\
g & h & i
\end{bmatrix}$
\end_inset

.
 Assume 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $A[x,y]+A[x+1,y+1]\leq A[x,y+1]+A[x+1,y]$
\end_inset

 for 
\begin_inset Formula $1\leq x\leq2$
\end_inset

 and 
\begin_inset Formula $1\leq y\leq2$
\end_inset

.
 Then we have 
\begin_inset Formula 
\begin{eqnarray*}
a+e & \leq & b+d\\
d+h & \leq & e+g
\end{eqnarray*}

\end_inset

and there fore 
\begin_inset Formula $a+e+d+h\leq b+d+e+g$
\end_inset

 which of course implies 
\begin_inset Formula $a+h\leq b+g$
\end_inset

.
 Similarly 
\begin_inset Formula $b+i\leq c+h$
\end_inset

.
 Combining these two inequalities we have 
\begin_inset Formula 
\begin{eqnarray*}
a+h+b+i & \leq & b+g+c+h\\
a+i & \leq & c+g
\end{eqnarray*}

\end_inset

This method readily generalizes to any size matrix (just 
\begin_inset Quotes eld
\end_inset

crawl
\begin_inset Quotes erd
\end_inset

 down a column and across a row).
 To prove the converse simply set 
\begin_inset Formula $k=i+1$
\end_inset

 and 
\begin_inset Formula $l=j+1$
\end_inset

 in 
\begin_inset Formula $A[i,j]+A[k,l]\leq A[i,l]+A[k.j]$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\begin{bmatrix}37 & 23 & 22 & 32\\
21 & 6 & 7 & 10\\
53 & 34 & 30 & 31\\
32 & 13 & 9 & 6\\
43 & 21 & 15 & 8
\end{bmatrix}\rightarrow\begin{bmatrix}37 & 23 & 22 & 32\\
21 & 6 & \mathbf{5} & 10\\
53 & 34 & 30 & 31\\
32 & 13 & 9 & 6\\
43 & 21 & 15 & 8
\end{bmatrix}$
\end_inset


\end_layout

\begin_layout Enumerate
Proof by contradiction: assume there exist 
\begin_inset Formula $i,j$
\end_inset

 such that 
\begin_inset Formula $i<j$
\end_inset

 but 
\begin_inset Formula $f(j)<f(i).$
\end_inset

 We have this arrangment
\begin_inset Formula 
\[
\begin{bmatrix}\ddots & \vdots & \vdots & \vdots & \iddots\\
\dots & A[i,f(j)] & \dots & A[i,f(i)] & \dots\\
\dots & \vdots & \ddots & \vdots & \dots\\
\dots & A[j,f(j)] & \dots & A[j,f(i)] & \dots\\
\iddots & \vdots & \vdots & \vdots & \ddots
\end{bmatrix}
\]

\end_inset

Then since 
\begin_inset Formula $f(i)$
\end_inset

 is the column index of the farthest-to-the-left minimum element we must
 have 
\begin_inset Formula $A[i,f(j)]>A[i,f(i)]$
\end_inset

 and therefore 
\begin_inset Formula $A[i,f(j)]+A[j,f(i)]>A[i,f(i)]+A[j,f(j)]$
\end_inset

, since 
\begin_inset Formula $A[j,f(j)]$
\end_inset

 is defined to be less than or equal to 
\begin_inset Formula $A[j,f(i)]$
\end_inset

.
 But this of course violates the Monge principle.
 
\end_layout

\begin_layout Enumerate
By part (c) in each row 
\begin_inset Formula $j$
\end_inset

 we know that for the left-most-minimum element 
\begin_inset Formula $A[j,f(j)]$
\end_inset

 it's the case that 
\begin_inset Formula $f(j-1)\leq f(j)\leq f(j+1)$
\end_inset

.
 Therefore in each in row 
\begin_inset Formula $j$
\end_inset

 we need to inspect only 
\begin_inset Formula $f(j+1)-f(j-1)+1$
\end_inset

 elements.
 In total this is at most 
\begin_inset Formula $n$
\end_inset

 elements.
 But in the instance when for some odd row 
\begin_inset Formula $j$
\end_inset

 it's the case that 
\begin_inset Formula $f(j+1)=f(j+2)$
\end_inset

 then 
\begin_inset Formula $A[j,f(j+2)]$
\end_inset

 will need to be checked even though 
\begin_inset Formula $A[j+2,f(j+2)]$
\end_inset

 was inspected as well.
 At most there will be 
\begin_inset Formula $m/2$
\end_inset

 such repeated inspections of already inspected columns and so in total
 there will be 
\begin_inset Formula $O(m+n)$
\end_inset

 inspections.
\end_layout

\begin_layout Enumerate
The recurrence relation is 
\begin_inset Formula $T(m,n)=T(m/2,n)+O(m+n).$
\end_inset

 Assume the inductive hypothesis 
\begin_inset Formula $T(k,j)=c_{1}(k+j\log k)$
\end_inset

.
 Then
\begin_inset Formula 
\begin{align*}
T(m,n) & \leq c_{1}\bigg(\frac{m}{2}+n\log\bigg(\frac{m}{2}\bigg)\bigg)+O(m+n)\\
 & \leq c_{1}(m+n\log(m)-n\log2)+O(m+n)\\
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[7.6]
\end_layout

\end_inset

This problem was solved with the help of http://alumni.media.mit.edu/~dlanman/cours
es/cs157/HW3.pdf
\end_layout

\begin_deeper
\begin_layout Enumerate
Let 
\begin_inset Formula $\text{points}[i][j]$
\end_inset

 be the 
\begin_inset Formula $n\times2$
\end_inset

 array with 
\begin_inset Formula $\text{points}[i][0]=a_{i}$
\end_inset

 and 
\begin_inset Formula $\text{points}[i][1]=b_{i}$
\end_inset

.
 Let 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

 be a function that computes intersections of subsets of intervals
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Find-Intersection(points,p,s)
\end_layout

\begin_layout Plain Layout

	j = random(p,s)
\end_layout

\begin_layout Plain Layout

	swap(points[p],points[j])
\end_layout

\begin_layout Plain Layout

	a = points[p][0]
\end_layout

\begin_layout Plain Layout

	b = points[p][1]
\end_layout

\begin_layout Plain Layout

	for i=p to s
\end_layout

\begin_layout Plain Layout

		//           a|---------|b
\end_layout

\begin_layout Plain Layout

		//  x|--------|y
\end_layout

\begin_layout Plain Layout

		//           u|------|v
\end_layout

\begin_layout Plain Layout

		// the only requirement for intersection is 
\end_layout

\begin_layout Plain Layout

		// that both the left end point of interval 
\end_layout

\begin_layout Plain Layout

		// being checked is <= b
\end_layout

\begin_layout Plain Layout

		// and the right end point is >= a so
\end_layout

\begin_layout Plain Layout

		if points[i][0] <= b and points[i][1] >= a
\end_layout

\begin_layout Plain Layout

			// check if narrower on the left
\end_layout

\begin_layout Plain Layout

			if points[i][0] > a
\end_layout

\begin_layout Plain Layout

				a = points[i][0]
\end_layout

\begin_layout Plain Layout

			// check if narrower on the right
\end_layout

\begin_layout Plain Layout

			if points[i][1] < b
\end_layout

\begin_layout Plain Layout

				b = points[i][1]
\end_layout

\begin_layout Plain Layout

	// the intersection interval
\end_layout

\begin_layout Plain Layout

	return (a,b)
\end_layout

\end_inset

The call to 
\begin_inset Formula $\text{random}$
\end_inset

 on line 2 is inorder to improve expected running time.
 If all intervals overlap then 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

 returns the largest region of overlap.
 Otherwise on average it returns the largest possible overlap of a subset
 of intervals.
 Then let 
\begin_inset Formula $\text{Partition-Intervals}$
\end_inset

 be essentially the same as 
\begin_inset Formula $\text{Partition}$
\end_inset

 from Quicksort except it takes a key to compare against, a flag to pick
 whether to compare 
\begin_inset Formula $a_{i}$
\end_inset

 or 
\begin_inset Formula $b_{i}$
\end_inset

, and a comparator 
\begin_inset Formula $\{\leq,\ge,<,>\}$
\end_inset

.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Partition-Intervals(points,p,r,flag,key,Comparator)
\end_layout

\begin_layout Plain Layout

	i = p-1
\end_layout

\begin_layout Plain Layout

	for j=p to s
\end_layout

\begin_layout Plain Layout

		// compare a_i or b_i
\end_layout

\begin_layout Plain Layout

		if points[j][flag] Comparator key   
\end_layout

\begin_layout Plain Layout

			i++
\end_layout

\begin_layout Plain Layout

			// swap intervals in the array
\end_layout

\begin_layout Plain Layout

			swap(points[i],points[j])
\end_layout

\begin_layout Plain Layout

	return i	
\end_layout

\end_inset

Finally 
\begin_inset Formula $\text{Fuzzy-Quicksort}$
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Fuzzy-Quicksort(points,x,y)
\end_layout

\begin_layout Plain Layout

	if x<y
\end_layout

\begin_layout Plain Layout

		(a,b) = Find-Intersection(points,x,y)
\end_layout

\begin_layout Plain Layout

		// right
\end_layout

\begin_layout Plain Layout

		r = Partition-Intervals(points,x,y,0,a,<=)
\end_layout

\begin_layout Plain Layout

		// left-middle
\end_layout

\begin_layout Plain Layout

		q = Partition-Intervals(points,x,r,1,b,<)
\end_layout

\begin_layout Plain Layout

		Fuzzy-Quicksort(points,x,q-1)
\end_layout

\begin_layout Plain Layout

		Fuzzy-Quicksort(points,r+1,y)
\end_layout

\end_inset

The first call to 
\begin_inset Formula $\text{Partition-Intervals}$
\end_inset

 sorts the intervals by their 
\begin_inset Formula $a_{i}$
\end_inset

 (hence 
\begin_inset Formula $\text{flag}=0$
\end_inset

) on 
\begin_inset Formula $\leq$
\end_inset

 around the 
\begin_inset Formula $a$
\end_inset

 returned by 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

.
 After this first call all intervals to the right of 
\begin_inset Formula $r$
\end_inset

 are outside of the intersection.
 Why? If there were an interval 
\begin_inset Formula $[a_{i},b_{i}]$
\end_inset

 such that some portion of it overlapped the intersection and 
\begin_inset Formula $a_{i}>a$
\end_inset

 then the it would have been considered in 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

 on line 16.
 Hence all intervals in 
\begin_inset Formula $\text{points}[i]$
\end_inset

 with indices 
\begin_inset Formula $i>r$
\end_inset

 are outside of the intersection.
 Therefore all intervals in 
\begin_inset Formula $\text{points}[i]$
\end_inset

 with indices 
\begin_inset Formula $i<r$
\end_inset

 are either inside the intersection or outside the intersection but on the
 left.
 The second call to 
\begin_inset Formula $\text{Partition-Intervals}$
\end_inset

 sorts the intervals by their 
\begin_inset Formula $b_{i}$
\end_inset

 (hence 
\begin_inset Formula $\text{flag}=1$
\end_inset

) on 
\begin_inset Formula $<$
\end_inset

 around the 
\begin_inset Formula $b$
\end_inset

 returned by 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

.
 After this second call all intervals to the left of 
\begin_inset Formula $q$
\end_inset

 are outside the intersection.
 Why? If there are an interval 
\begin_inset Formula $[a_{i},b_{i}]$
\end_inset

 such that some portion of it overlapped the intersection and 
\begin_inset Formula $b_{i}\geq b$
\end_inset

 then it would have been considered by 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

 on line 19.
 Therefore all intervals in 
\begin_inset Formula $\text{points}[i]$
\end_inset

 with indices 
\begin_inset Formula $i<q$
\end_inset

 are outside the intersection but on the left.
 Therefore all intervals in 
\begin_inset Formula $\text{points}[i]$
\end_inset

 with 
\begin_inset Formula $q\leq i\leq r$
\end_inset

 are in the intersection and their permutation is irelevant because we know
 they intersect and therefore either 
\begin_inset Formula $a$
\end_inset

 or 
\begin_inset Formula $b$
\end_inset

 returned by 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

 is a correct 
\begin_inset Formula $c^{*}$
\end_inset

 such that 
\begin_inset Formula $[a_{j},b_{j}]\,\forall j\in\{[a_{q},b_{q}],\dots,[a_{r},b_{r}]\}$
\end_inset

.
\end_layout

\begin_layout Enumerate
The macroscopic structure of 
\begin_inset Formula $\text{Fuzzy-Quicksort}$
\end_inset

 is almost the same as 
\begin_inset Formula $\text{Randomized-Quicksort}$
\end_inset

 .
 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

 is clearly 
\begin_inset Formula $\Theta(n)$
\end_inset

 since it considers every interval.
 Note also that when all intervals are disjoint 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

 returns just the first interval, the one chosen by 
\begin_inset Formula $\text{random}$
\end_inset

 on line.
 Therefore in such an instance 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

 has exactly the same effect as wrapper 
\begin_inset Formula $\text{Randomized-Partition}$
\end_inset

 for 
\begin_inset Formula $\text{Partition}$
\end_inset

 on page 179 of CLRS.
 
\begin_inset Formula $\text{Partition-Intervals}$
\end_inset

 is almost exactly the same as 
\begin_inset Formula $\text{Quicksort}$
\end_inset

 's 
\begin_inset Formula $\text{Partition}$
\end_inset

 and so runs in 
\begin_inset Formula $\Theta(n)$
\end_inset

.
 Therefore worst case is similarly 
\begin_inset Formula $\Theta(n\lg n)$
\end_inset

.
 Best case is when all intervals intersect, in which case 
\begin_inset Formula $\text{Find-Intersection}$
\end_inset

 returns an intersection that's contained every interval and the first call
 to 
\begin_inset Formula $\text{Partition-Intervals}$
\end_inset

 returns index 
\begin_inset Formula $y$
\end_inset

 and the second call returns index 
\begin_inset Formula $x$
\end_inset

 and the two recursive calls return immediately since 
\begin_inset Formula $x\nleq x-1$
\end_inset

 and 
\begin_inset Formula $y+1\nleq y$
\end_inset

.
 Therefore in this case, when all the intervals overlap the algorithm runs
 in 
\begin_inset Formula $\Theta(n).$
\end_inset

 
\begin_inset Formula $ $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[8.4]
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Compare every red jug to every blue jug.
 Exactly 
\begin_inset Formula $n^{2}$
\end_inset

 units of time.
 Hence 
\begin_inset Formula $\Theta(n^{2})$
\end_inset

.
\end_layout

\begin_layout Enumerate
Fix a permutation of the red jugs, call it 
\begin_inset Formula $(r_{1},r_{2},\dots,r_{n})$
\end_inset

.
 Note that it is not necessarily the case that 
\begin_inset Formula $r_{i}\leq r_{j}$
\end_inset

 if 
\begin_inset Formula $i<j$
\end_inset

 or anything like this.
 Then the problem is tantamount to finding a permutation of blue jugs, 
\begin_inset Formula $(b_{\pi(1)},b_{\pi(2)},\dots,b_{\pi(n)})$
\end_inset

 such that 
\begin_inset Formula $b_{\pi(i)}=r_{i}$
\end_inset

.
 Note there are 
\begin_inset Formula $n!$
\end_inset

 such permutations.
 Any comparison based algorithm must distinguish between 3 different cases
 at each step: either 
\begin_inset Formula $b_{\pi(i)}<r_{j}$
\end_inset

 or 
\begin_inset Formula $b_{\pi(i)}>r_{j}$
\end_inset

 or 
\begin_inset Formula $b_{\pi(i)}=r_{j}$
\end_inset

 and overall must distinguish between 
\begin_inset Formula $n!$
\end_inset

 permutations of the 
\begin_inset Formula $b_{i}$
\end_inset

.
 Thus the decision tree that a comparison based algorithm must traverse
 is a 3-ary tree with minimum height 
\begin_inset Formula $h\geq\log_{3}n!$
\end_inset

.
 Then by 
\series bold
eqn.
 3.19
\series default
 in CLRS we have that 
\begin_inset Formula $h\ge\Theta(n\lg n)$
\end_inset

.
\end_layout

\begin_layout Enumerate
Pick a random blue jug, the 
\begin_inset Quotes eld
\end_inset

blue pivot
\begin_inset Quotes erd
\end_inset

, and use Randomized-partition to partition all the red jugs into bigger,
 smaller, and equal.
 Then use the red jug that's equal in size to the blue pivot, call it the
 
\begin_inset Quotes eld
\end_inset

red pivot
\begin_inset Quotes erd
\end_inset

 to similarly partition all blue jugs.
 Then recurse choosing a random new 
\begin_inset Quotes eld
\end_inset

blue pivot
\begin_inset Quotes erd
\end_inset

 in each of the 
\begin_inset Quotes eld
\end_inset

smaller-than
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

bigger-than
\begin_inset Quotes erd
\end_inset

 sets.
 The recurrence relations is the same as for Randomized-quicksort except
 the divide step uses Randomized-partition twice instead of once.
 So absorbing the constant factor the recurrence relation is 
\begin_inset Formula $T(n)=\underset{0\le q\le n-1}{\max}(T(q)+T(n-q-1))+2\Theta(n)=\underset{0\le q\le n-1}{\max}(T(q)+T(n-q-1))+\Theta(n)$
\end_inset

.
 Hence by the analysis of Quicksort we have have expected running time of
 
\begin_inset Formula $O(n\lg n)$
\end_inset

, with worst case running 
\begin_inset Formula $\Theta(n^{2}).$
\end_inset


\end_layout

\end_deeper
\end_body
\end_document
