#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble

%
\usepackage{mathdots}
\usepackage{listings}
\usepackage{tikz}
\usepackage{pgf}
\usepackage{tikz-qtree}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{amsfonts}\usepackage{nopageno}%%%  The following few lines affect the margin sizes. 
\addtolength{\topmargin}{-.5in}
\setlength{\textwidth}{6in}       
\setlength{\oddsidemargin}{.25in}              
\setlength{\evensidemargin}{.25in}         
  
\setlength{\textheight}{9in}
\renewcommand{\baselinestretch}{1}
\reversemarginpar   

\lstset{
numbers=left
}


%
%
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=single"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
COT5405 Homework 5 Solutions
\end_layout

\begin_layout Author
Maksim Levental
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.1-1]
\end_layout

\end_inset

Definition of cross-product, i.e let 
\begin_inset Formula $p_{1}=\left(a_{1},b_{1}\right)$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $p_{2}=\left(a_{2},b_{2}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.1-2]
\end_layout

\end_inset

Fails if one line segment is flat.
 Then the point could be outside the line segment but still have the same
 y coordinate.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.1-3]
\end_layout

\end_inset

Just implement a comparator that compares using cross-product
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.1-4]
\end_layout

\end_inset

Fix a point p.
 determine polar angles wrt this point of all other points, in sorted order,
 in nlgn time.
 then go through the array and see if any 2 are the same.
 they will be neighbors.
 if you hadn't sorted you would have to search in the array for each n-1
 entry to see if it matches any other entry.
 then repeat for each point.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.1-5]
\end_layout

\end_inset

How do you handle the case when a series of 3 points is a flat face of a
 polygon? How do you distinguish between just a straight line and a flat
 face? Also what about spirally points that self intersect? Eliminating
 straight lines is easy - if all cross products are zero then it's a straight
 line.
 Eliminating spirals is harder.
 Sumer of the interior angles of a polygon is 180(n-2).
 So compute all interior angles.
 If they exceed 180(n-2) then not a polygon and therefore can't be a convex
 polygon.
 
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.1-6]
\end_layout

\end_inset

The vector in the direction of the right ray length adequate enough to intersect
 with any segment is 2*norm(p1p2)*((x0,y0)-(x0+1,y0)).
 Then test the intersection.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.1-7]
\end_layout

\end_inset

use the winding number, which is non-zero only if you're inside the polygon.
 for polygons the winding number is computed as the sum of the signed angle
 between the point and all pairs of endpoints on the faces (in counter clockwise
 order).
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.1-8]
\end_layout

\end_inset

Label all of the points in a counter clockwise manner.
 Then pick any point in the plane compute the area of the triangles 
\begin_inset Formula $\left(p,v_{0},v_{1}\right),\left(p,v_{1},v_{2}\right),\cdots,\left(p,v_{n-1},v_{n}\right)$
\end_inset

.
 By green's theorem summing these will yield the area (those triangles which
 end up being clockwise oriented will contribute negative areas).
 pick any point in the plane and compute the areas of all the triangles
 for triplets with the point and edge ends.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.2-1]
\end_layout

\end_inset

Duh.
 If it's a complete graph.
 First vertex connects to 
\begin_inset Formula $n-1$
\end_inset

 vertices, then the second connects to 
\begin_inset Formula $n-2$
\end_inset

 and etc.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.2-2]
\end_layout

\end_inset

If the lines don't intersect the one is always either above or below and
 so you can just do a cross-product of either starting points or end points.
 If they intersect then compute whether the intersection happens before
 x or after x.
 You can do this (somehow?) if the intersection happens before x then check
 the right endpoints.
 if the intersection happens after x then check the left end points.
 if the intersection happens before x then compare the right endpoints.
 if the intersection happens after x then compare the left end points.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.2-3]
\end_layout

\end_inset

It will not always find the left most endpoint.
 Example is on page 1026.
 Shrink D to be further ahead of the left end point of e but still underneath
 and then have right endpoint of c end right where e begins.
 then e and b will be consecutive when c is removed and the intersection
 will be thrown up but it will actually be an intersection that's ahead
 of the intersection between d and b.
 The routine will always find all intersections though, as it must in order
 for the algorithm to work at all.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.2-4]
\end_layout

\end_inset

Using the line sweep algorithm to count the number of intersections, ignoring
 intersections at mutual endpoints.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.2-5]
\end_layout

\end_inset

Use the sweep luke!
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.2-6]
\end_layout

\end_inset

two disks intersect iff 
\begin_inset Formula $\sqrt{\left(x_{1}-x_{2}\right)^{2}+\left(y_{1}-y_{2}\right)^{2}}\leq\left(r_{1}+r_{2}\right)^{2}$
\end_inset

.
 Very similar to two lines intersecting.
 sort on the x coordinates and y coordinates of their centers.
 two event points being the left most point of the disk the right most point
 of the disk, i.e.
 their projections onto the x axis.
 inserting them into a tree structure according to their y coordinate and
 using the same algorithm as line segment intersections.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.2-7]
\end_layout

\end_inset

keep a sweep-line status structure: an RB tree of segments that the sweep
 line intersects currently.
 also keep an event list: a priority queue of of endpoints and intersections
 points.
 just like sweepline algo if an event is a left endpoint insert into T.
 if an intersection is computed then insert into events list (why?).
 if an event is a right endpoint then delete from T and if there's an intersecti
on found then insert into event's list.
 if an intersection event occurs then switch their order in T.
 if new neighbors intersect the switches lines insert them into event list.
 right.
 this is the only thing that the other algorithm doesn't do since it doesn't
 update the order of the lines in the structure after an intersection is
 passed.
 sorting takes nlogn, each update takes logn and updated the priority queue
 (on x coordinate) takes log(n+k)=log(n).
 therefore for 2n+k events it's O((n+k)logn).
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.2-8]
\end_layout

\end_inset

If three segments intersect at a point then the intervening line segment
 and the line segment above it will intersect and that will be checked on
 insertion of either the top of bottom line segment.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.2-9]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.3-1]
\end_layout

\end_inset

since 
\begin_inset Formula $p_{1}$
\end_inset

 is the the point with the shallowest polar angle and 
\begin_inset Formula $p_{m}$
\end_inset

is the point with the largest polar angle they must be in the convex hull.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.3-2]
\end_layout

\end_inset

create the triangles 
\begin_inset Formula $\left(0,0\right),\left(0,i\right),\left(a(i),0\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.3-3]
\end_layout

\end_inset

since they're farthest from each other the points around them must be the
 correct direct turns, otherwise one of the four would be farther.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.3-4]
\end_layout

\end_inset

run graham's scan on just the verices, but you don't have to sort since
 the points are already given in sorted order.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.3-5]
\end_layout

\end_inset

since a ch(k-1) is an ordered listing of the vertices of the convex hull
 no sorting will need to be done upon addition of the new point.
 if the point is in the interior, which can be checked using cross product
 (for every point on the hull pi->pi+1->pk is a left turn).
 if the pk is outside of the convex hull then then first point that should
 be in sequence with it in the new convex hull is that for which pi->pi+1->pk
 is a right turn.
 then j such that it's the first after i for which pj->pj+1->pk is a left
 turn.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.3-6]
\end_layout

\end_inset

Incremental method is the same online method except it's not online, i.e.
 you have all the points and you just add them 1 by 1.
 to get a n log n time presort the points so that you're always adding points
 that are outside the current convex hull and still do the same thing, i.e
 look for first pi such that pi->pi+1->pk is a right turn, and then pj such
 that pj->pj+1->pk is a left turn.
 Alternatively look for first switch in direction i.e.
 first point pi such that pi-1->pi is right of p but pi->pi+1 is left of
 p.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.4-1]
\end_layout

\end_inset

Potentially the balanced split of all of the points would be violated (imagine
 all of the points on the dividing line - they would all go into P_L).
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.4-2]
\end_layout

\end_inset

Since you only have to check for points within d of any point in the array.
 draw a bounding box +-d in the y direction plus d in the x direction
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename pasted1.png

\end_inset

This bounding box can hold at most 6 distinct points.
 therefore only 5 array positions need to be checked.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.4-3]
\end_layout

\end_inset

The only difference now is that the bounding box is ?twice? as big? holds
 16 points?
\begin_inset Graphics
	filename pasted2.png

\end_inset

any points on the corners of the d/2 boxes are d apart.
 alternating diagonals gives you 13 total points.
 why 2 delta? only 1 delta right? 7 points.
 nope 9.
 you get two more points at the centers of the boxes.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.4-4]
\end_layout

\end_inset

no change
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.4-5]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[33.4-6]
\end_layout

\end_inset

suggest a chance the avoid presorting the array Y but leaves the running
 time nlgn (merge sorted arrays Y_L and Y_R to form the sorted array Y).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

farthest pair problem.
 farthest pair is on the convex hull.
 you can pick an arbitrary point on the hull, find it's antipode.
 antipodal pairs
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.1-1]
\end_layout

\end_inset

if LONGEST-PATH-LENGTH can be solved in polynomial time then you can solve
 the decision problem by checking if longest path returned by LONGEST-PATH-LENGT
H is larger than k.
 if LONG-PATH can be solved in polynomial time then LONGEST-PATH-LENGTH
 can be solved by incrementing k until LONGEST-PATH returns a no answer.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.1-2]
\end_layout

\end_inset

an instance of longest simple cycle is an undirected graph G with integer
 k and asks whether there exists a simple cycle of length at least k.
 it is np-hard by reduction from hamiltonian cycle (simple cycle that visits
 all vertices).
 the reduction is that we pose the question whether there exists a cycle
 of length equal to the number of vertices.
 duh.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.1-3]
\end_layout

\end_inset

just write out the unroll the adjacency matrix into an n^2 bit string.
 how would you encode an adjacency list representation of a graph using
 binary strings
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.1-4]
\end_layout

\end_inset

sure? O(nW)?
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.1-5]
\end_layout

\end_inset

polynomial number of calls to a polynomial time subroutine might result
 in an exponential time algorithm.
 suppose S_i has a running time of n^e for input size n but the input size
 is now m_i=2^i-1 * n.
 then S_n has input size 2^n-1 n so its running time is linear in 2^n-1
 n, which is not polynomial time.
 if the output is twice the size of input then feeding output into input
 over and over again produces n2^n output, not polynomial.
 if the output is twice as large as the input and you just keep feeding
 it into the input.
 then on the nth run you'll have a 2^n input it will take an exponential
 amount of time.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.1-6]
\end_layout

\end_inset

language is a set, any set of strings over an alphabet.
 union, intersection,concatenation, complement (in the kleene star), kleene
 star is closure .
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.2-1]
\end_layout

\end_inset

a verification certificate is an encoding of a permutation of the vertices
 of G1 such that after renaming you can compare the adjacency matrices of
 G1 and G2 and they're equal.
 Graph-isomorphism is unknown to be np-complete.
 interesting.
 subgraph isomorphism is np complete by reduction from clique? if there's
 a clique of size k then it's isomorphic to a complete subgraph K_k.
 make G the entire graph and ask if there's a complete subgraph K_k.
 if and only if obviously.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.2-2]
\end_layout

\end_inset

by contradiction.
 find a hamiltonian cycle, remove edge v1vn, and a partition of the graph
 into sets V1 V2.
 assume that v1 in V1 and then by induction every odd number node is in
 V1, so vn is in V1.
 but then v1 vn could never have had an edge to begin with because they
 were in the same bipartition of the graph.
 construct a bipartition.
 take some vertex v1 in the left partition.
 get your hamiltonian cycle.
 the edge forward from v1 must go to the right partition and by induction
 all odd vertices are in the left partition.
 but by bipartite you couldn't have had v1vn connected.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.2-3]
\end_layout

\end_inset

a path that visits each vertex exactly once - hamiltonian cycle.
 in a hamiltonian cycle there are two edges per node.
 take an arbitrary vertex and find which pair of edges incident on it are
 part of the hamiltonian cycle by removing all edges incident on it from
 the edge set and adding all possible pairs.
 then recursively do this for all other nodes.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.2-4]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.2-5]
\end_layout

\end_inset

generate all strings and verify them
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.2-6]
\end_layout

\end_inset

HAM-PATH is reducible from vertex cover (not simple).
 but polynomial verification is easy (just check whether all vertices are
 visited).
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.2-7]
\end_layout

\end_inset

On a dag we can just topologically sort (depth first search with open/close
 times).
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.2-8]
\end_layout

\end_inset

all instances in TAUTOLOGY are encodings of boolean formulas which are always
 true.
 if a formula is not in TAUTOLOGY, not a tautology, then it is not always
 true, i.e.
 sometimes false.
 then deciding whether an instance is in TAUTOLOGY-COMP amounts to computing
 whether a boolean formula has an 
\begin_inset Quotes eld
\end_inset

unsatisfying unsignment
\begin_inset Quotes erd
\end_inset

, which is of course has polynomial time verification.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.2-9]
\end_layout

\end_inset

p in co-np.
 if a language is polynomial time decidable 
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.2-11]
\end_layout

\end_inset

prove that G^3 undirected graph is hamiltonian.
 since any connected graph has a spanning tree it suffices to prove it for
 T^3 where T is the spanning tree of G.
 we prove that for any edge in T T^3 has a hamiltonian cycle that contains
 that edge (this implies that T^3 is hamitonian).
 by induction on n, the number of vertices in T.
 the case for n=3 is obvious since the cube is a clique.
 assume the induction hypothesis and pick an arbitrary edge in T.
 we now construct a hamiltonian cycle in T^3 that contains the edge.
 since T is a tree removing a single edge disconnects it.
 let T_u be the part that has more than 3 vertices.
 by induction hypo there is a hamiltonian cycle in T_u^3 which includes
 u and u', a neighbor of the edge we selected.
 now for T_v^3.
 if T_v contains only one vertex then by adding v in between u' and u, which
 can be done since by the triangle inequality d_T(u',v)=(u,u')+(u,v)=2,
 less than 3, dictates there's an edge in T^3 from u' to v.
 If T_v contains two vertices then do the same thing but stick both of them
 in between u' and u, and by similar reasoning there are edges.
 if T_v contains at least 3 vertices then by induction hypothesis there's
 a hamiltonian cycle in T_v^3.
 because of reasoning above, close enough in edge distance, so we remove
 uu' and vv', and we can connect u',v' and u,v and have a hamiltonian cycle
 across the whole T^3.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.3-1]
\end_layout

\end_inset

try all 8 different combinations of 0 and 1
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.3-2]
\end_layout

\end_inset

transitive relation on languages.
 polynomial function of polynomial blah blah blah
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.3-3]
\end_layout

\end_inset

By definition 
\begin_inset Formula $L\leq_{P}\bar{L}\iff L\leq_{P}\left(\left\{ 0,1\right\} ^{*}-L\right)$
\end_inset

 means there exists a polynomial time computable function 
\begin_inset Formula $f:\left\{ 0,1\right\} ^{*}\rightarrow\left\{ 0,1\right\} ^{*}$
\end_inset

 such that 
\begin_inset Formula $x\in L\iff f\left(x\right)\in\bar{L}$
\end_inset

.
 But this also means that 
\begin_inset Formula $x\notin L\iff f\left(x\right)\notin\bar{L}$
\end_inset

 and therefore 
\begin_inset Formula $x\in\bar{L}\iff f\left(x\right)\in L$
\end_inset

.
\begin_inset Formula 
\[
\left(x\in L\iff f\left(x\right)\in\bar{L}\right)\iff\left(x\notin L\iff f\left(x\right)\notin\bar{L}\right)\iff\left(x\in\bar{L}\iff f\left(x\right)\in L\right)
\]

\end_inset

since 
\begin_inset Formula $x\notin L$
\end_inset

 means exactly 
\begin_inset Formula $x\in\bar{L}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.3-4]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.3-5]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.3-6]
\end_layout

\end_inset

to reduce one L' in P to any other L in P construct the mapping from L'
 to L by deciding L' in polynomial time and setting f(x) to be that decision.
 This cannot be done for the two trivial languages.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.3-7]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.4-5]
\end_layout

\end_inset

disjunctive is or (conjunction is and) and so we just check one by one whether
 any of the clauses between the ors is satisfiable.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.4-6]
\end_layout

\end_inset

convert variables to literals, i.e.
 let v_i = 1 and run the deciding algo.
 if yes then keep 1 otherwise, change v_i = 0.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.4-7]
\end_layout

\end_inset

construct a graph with a vertex for each of x_i and ~x_i.
 then for every clause x_i V x_j create edges (~x_i,x_j) and (~x_j,x_i).
 the formula is satisfiable iff no vertices corresponding to complementary
 nodes are in the same strongly connected component.
 if the formula is sat then no pair of literals in the same component, if
 no pairs of literals in the same component then formula is sat.
 by the hint ~x->y <-> xVy we know that if there is a path from ~x to x
 and x to ~x then they must have the same values because the paths are a
 chain of implications.
 conversely suppose no pair of complimentary literals are in the same strongly
 connected component.
 conversely construct the truth assignment based on topological sort of
 nodes.
 if x_i precedes ~x_i then set x_i=0, otherwise x_i=1.
 ie start setting all components to false (which determines their negations).
 this is 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

sat => no literals and neg in same components <=> if a literal and negation
 in the same component then no sat: if literal and negation in same component
 then both false both true no sat.
\begin_inset Newline newline
\end_inset

no literal and neg in same component => there exists sat (constructive)
 : 1.
 all literals in a strongly connected component 2.
 condense the graph (dag of strongly connected components).
 assign false to root and therefore true to all negations.
 continue on to next connected component miniclaim: you will never have
 true => false and therefore satisfied.
 since all literals in a component same true value suffices to show no (A,B)=(1,
0) with A->B.
 we can assume literals in A and B will be disjoint (otherwise we would
 have already assigned 0s and 1s correctly).
 since there's a path from a in A to b in B there's a path from ~b to ~a
 (flip the implication).
 Let ~b in B' and ~a in A'.
 Then (A,B)=(1,0) <=> (B',A')=(1,0) which means that A' preceded A and B
 preceded B' which gives the cycle A->B->B'->A' (since ~b -> ~a).
 a contradiction.
 therefore (A,B)=(1,0) never happens and our assignment scheme is satisfying.
 
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.5-1]
\end_layout

\end_inset

subgraph isomorphism.
 a clique is a subgraph that's a complete graph (each pair in the set of
 vertices has an edge).
 reduce from clique.
 Let (G,k) be the clique of size k problem.
 define G1 to be the complete graph on k vertices and then ask whether G1
 is a subgraph of G.
 if there's a clique then there's a subgraph isomorphic K_k and if there's
 a subgraph isomorphic to K_k then there's a clique.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.5-2]
\end_layout

\end_inset

add the inequalities 0<x_i<1 and express each clause as an inequality, ie
 (x1 V ~x2 V x3) as x1 + (1-x2)+x3 >= 1.
 if sat has a solution then x1 + (1-x2)+x3 will be greater than 1, at best
 x1=1, x2=0 ie (1-x2)=1, x3=1 and therefore x1 + (1-x2)+x3 = 3.
 and all simple inequalities are satisfied.
 if sat fails then at least some clause has all zeros and for that clause,
 the corresponding inequality will not be met and the ip won't have a feasible
 solution.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.5-3]
\end_layout

\end_inset

if you could solve ILP in P then you could obviously solve 0-1 ILP in P
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.5-4]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.5-5]
\end_layout

\end_inset

reduce from subset-sum.
 Let S,t,s be the 3 things for subset sum.
 then 2 cases.
 if 2t>s then throw in 2t-s.
 first check if subsetsum has a solution then partition has a solution.
 then the total sum is 2t and the partition will partition the new set into
 two sets each of which sum to t.
 now the element 2t-s will be in the subset of elements of S that sum to
 s-t since 2t-s + (s-t)=t and then the other set must be the subset of elements
 that sum to t.
 now check if partition has a solution then subset has a solution.
 since partition has a solution it means there's a subset of elements of
 Su(2t-s) that sums to (2t-s+s)/2=t.
 but by aforementioned arguments, i.e.
 that the element (2t-s) can only be in a set with elements that sum to
 (s-t) it must be the case that the other set in the partition, the one
 that (2t-s) is not a member of, contains only elements from S and sums
 to t.
 if 2t<s then for t'=(s-t) 2t'>s and we do the same thing, except now clearly
 if there's a partition then a subset sums to s-t which means its complement
 sums to t.
 this shows that if subsetsum has a solution then partition has a solution.
 now if partition has a solution then S U (2t'-s)= S U (2(s-t)-s) = S U
 (s-2t) = 2s-2t and each partition is of the size s-t but then s-2t + t
 = s - t so whichever set contains the element s-2t also contains the subset
 of S that sums to t.
 
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.5-6]
\end_layout

\end_inset

pick any vertex and duplicate it with all of its edges.
 then add nodes v and v', hanging off of the old vertex and the new vertex.
 if there's a hamiltonian cycle in G then there's a hamiltonian path in
 G' from v to v'.
 conversely if there's a hamiltonian path then it must have endpoints v
 and v' so we delete them and join u to u'.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.5-7]
\end_layout

\end_inset

reduce from hamiltonian cycle by asking if there's a longest simple cycle
 of size |E|
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34.5-8]
\end_layout

\end_inset

reduce from 3CNF.
 suppose 
\begin_inset Formula $\phi$
\end_inset

 is a formula for 3cnf with n variables and m clauses.
 create 3 more variables 
\begin_inset Formula $p,q,r$
\end_inset

 and 3m more clauses.
 m clauses of the form 
\begin_inset Formula $\left(p\vee\neg p\vee q\right)$
\end_inset

, 2m clauses of the form 
\begin_inset Formula $\left(p\vee q\vee r\right)$
\end_inset

.
 all of the latter clauses are all true or all false (duh because they're
 the same) and 
\begin_inset Formula $\left(p\vee\neg p\vee q\right)$
\end_inset

 are always true.
 the if and only if proof: if 3cnf is sat then set p and r to false and
 
\begin_inset Formula $\left(p\vee q\vee r\right)$
\end_inset

 will be false and there will be 2m (all those from 
\begin_inset Formula $\phi$
\end_inset

 and all 
\begin_inset Formula $\left(p\vee\neg p\vee q\right)$
\end_inset

) true clauses.
 if half sat is satisfied then 2m clauses are sat but since 
\begin_inset Formula $\left(p\vee\neg p\vee q\right)$
\end_inset

 are always true it can't be the case that all of the 
\begin_inset Formula $\left(p\vee q\vee r\right)$
\end_inset

 are true so therefore only those from 
\begin_inset Formula $\phi$
\end_inset

 must be true.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34-1]
\end_layout

\end_inset

independent set - a set of vertices no two of which are adjacent.
 The complement graph is the graph composed of the same vertices as the
 original graph but with an edge in the edge if and only if the original
 edge does not contain that edge.
 i.e.
 complement in the complete graph.
 a clique in one is an independent set in the other.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

run the independent set algo for k=1,2,...
 until you get a no, largest such k.
 then remove a vertex and ask the question again.
 if yes then recursively remove, other wise if you get a no remove a different
 one.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

each vertex has degree 2 means the graph is a collection of disjoint cycles
 and each cycle has length C_i.
 therefore every other vertex (odd vertices) on each of those cycles is
 an independent set and the total size is sum(number of cycles/2).
 return yes if that number is k.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

partition the graph into L and R.
 append a source node and sink node, connecting everything L to source with
 edge weight 1 and every R to sink with edge weight 1, and connected nodes
 to their partners in LR with weight inf.
 then run max flow to find mincut.
 any nodes that don't participate in the cut are part of the independent
 set because otherwise the the edge connecting them would have been cut
 since it has infinite weight.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[34-4]
\end_layout

\end_inset

the decision problem is given k does there exists a schedule that nets profit
 no less than k.
 verifying just means making sure that there's no overlap, that they finish
 on time, and the profit is at least k (they finish on time).
 np hard by reducing from subset sum.
 subset sum is X=xi,k then scheduling is Y=(profits=xi,deadlines=di,timeunits=xi
) (di = deadlines) di = k for all i.
 suppose the exists a subset that sums to k.
 then the schedule of jobs will finish before time k since they all have
 to overlapping and all finish before k.
 if there's a schedule that finishes before time k, the deadline, sum the
 sum of xi is less than k, then by the profit constraint it's over k so
 less than and greater than implies equal to.
 ie there's a sum equal to k.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

optimal substructure is that any schedule of n jobs must consist of n-1
 jobs scheduled optimally plus the most profitable jobs that fits next.
 sort the jobs by deadline.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

nrowsxn^2 colums:
\begin_inset Quotes eld
\end_inset

We keep a grid of the n jobs versus time (i.e.
 the actual in situ schedule as a function of time with 0 while jobs are
 running, column index is row and row index is how many of the first n jobs
 we've included).
 We initialize the first row in the table by figuring out our possible profit
 based on completeing the first job (jobs are sorted by deadline) at exactly
 time t.
 so we will have a profit of 
\begin_inset Formula $p_{1}$
\end_inset

 in the cell 
\begin_inset Formula $t_{1}$
\end_inset

 if 
\begin_inset Formula $t_{1}\leq d_{1}$
\end_inset

 and profit of zero otherwise 
\begin_inset Formula 
\[
T[1,t]=\begin{cases}
0 & if\; t\neq t_{1}\\
p_{1} & if\; t=t_{1}\leq d_{1}\\
0 & if\; t=t_{1}>d_{1}
\end{cases}
\]

\end_inset

then at each cell is set as a function of previous row.
 there's the choice of whether or not to run job i, no then the profit is
 
\begin_inset Formula $T\left[i-1,t\right]$
\end_inset

, which could be zero if it doesn't fall on a 
\begin_inset Formula $d_{i}$
\end_inset

.
 if we do perform job i then it takes 
\begin_inset Formula $t_{i}$
\end_inset

 units to complete, so the subproblem solution must have finished at 
\begin_inset Formula $t-t_{i}$
\end_inset

, and then this nets a profit of 
\begin_inset Formula $p_{i}$
\end_inset

 if this set of jobs finishes before 
\begin_inset Formula $d_{i}$
\end_inset

, otherwise we get the profit of the subproblem that finishes at 
\begin_inset Formula $t-t_{i}$
\end_inset

 hence.
 
\begin_inset Formula 
\[
T[i,t]=\begin{cases}
T\left[i-1,t\right] & \text{if we do not decide to perform job }i\\
T\left[i-1,t-t_{i}\right]+p_{1} & if\; t\leq d_{i}\\
T\left[i-1,t-t_{i}\right] & if\; t>d_{i}
\end{cases}
\]

\end_inset

running time is O(n^3).
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.1-1]
\end_layout

\end_inset

vertex cover approx alg - add edges while removing any other connected to
 edge end points ( the end vertices cover those edges already).
 suboptimal solution always.
 just the two edge graph.
 the optimal cover is one vertex but approx will return both.
 
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.1-2]
\end_layout

\end_inset

maximal matching: independent set, set of edges without common vertices,
 so duh since the set of edges chosen is such that edges both incident to
 the same vertex cannot be picked.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.1-3]
\end_layout

\end_inset

bipartite L u R where R nodes keep increasing in connectedness.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.1-4]
\end_layout

\end_inset

optimal vertex cover for a tree.
 start by looking at the leaves.
 pick a vertex that has at least one leaf.
 it certainly needs to be in the cover.
 then remove it and all edges.
 keep going.
 start by looking at the leaves, their parents have to be in the vertex
 cover, remove and recurse.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.1-5]
\end_layout

\end_inset

vertex cover and clique are related polynomially but the reduction might
 alter the approximation ratio.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Theorem: let V' sub V in G.
 V' a vertex cover <=> V-V' is independent <=> V-V' is a clique in G^c.
 vertex cover is the same as a maximal independent set.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.2-1]
\end_layout

\end_inset

metric TSP: construct an MST, pre-order walk the tree.
 assume not then then it violates the triangle inequality
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.2-2]
\end_layout

\end_inset

sum all the weights of tsp with no triangle inequality and add k to all
 edges.
 new instances satisfies triangle inequality and optimal tour remains the
 same since we simply lifted them up by nk.
 does not contradict 35.3 because doesn't give constant ratio algorithm for
 general problem.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

35.2-3]
\end_layout

\end_inset

suppose you're at some ith iteration of the closest point algo.
 let ui be the closest node to the tour and vi the closest node to it on
 the tour.
 add two edge (vi,ui), (ui,vi).
 then delete the duplicate node vi, so you have the sequence vi->ui->vi+1.
 the cost incurred in adding ui then is <= 2c(vi,ui) and therefore for all
 added edges C(T)<=sum(2c(vi,ui))=2sum(c(vi,ui)).
 but prim's mst proceeds in this exact same way , ie sum(c(vi,ui)) and therefor
 c(T)<=2sum(c(vi,ui))<=2c(MST), but c(MST)<=c(OPT) by clrs so c(T)<=2c(OPT).
 
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.2-4]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.2-5]
\end_layout

\end_inset

by triangle inequality eliminating a cross always reduces the cost of the
 tour.
 AB < AX + XB
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.3-1]
\end_layout

\end_inset

greedy set cover: pick the set that covers the greatest number of elements:
 {a,d,e,h,i,l,n,o,r,s,t,u}.
 thread {i,l,n,o,s,u}, lost {i,n,u}, shun {i}, arid
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.3-2]
\end_layout

\end_inset

SET-COVER = {X,F,k|X has a cover of size k, k elements in F}.
 The edges in vertex cover are elements in X and vertices are subsets.
 
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.3-3]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.3-4]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.3-5]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[35.5-1]
\end_layout

\end_inset

approx subset sum.
 try all sums but trims those which are close.
\end_layout

\begin_layout Enumerate
the complement of a clique in a graph is an independent set.
 
\end_layout

\end_body
\end_document
