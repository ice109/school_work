#include <GL/glew.h>
#include <GL/glut.h>
#include <algorithm> // min, max
#include <iostream> //std::cout, std::endl
#include <vector>
#include <map>
#include <iomanip> //std::setw
#include "surfaces.h"

std::vector<surface*> surfaces;

static inline void loadbar(unsigned int x, unsigned int n, unsigned int w = 50)
{
    if ( (x != n) && (x % (n/100) != 0) ) return;
 
    float ratio  =  x/(float)n;
    int   c      =  ratio * w;
 
    std::cout << std::setw(3) << (int)(ratio*100) << "% [";
    for (int x=0; x<c; x++) std::cout << "=";
    for (int x=c; x<w; x++) std::cout << " ";
    std::cout << "]\r" << std::flush;
}



void makeCheckImage(std::vector<surface*>& bob) {

  int i, j; 
  int c = 0;

  for (i = 0; i < CHECK_IMAGE_HEIGHT; i++){
    
    for (j = 0; j < CHECK_IMAGE_WIDTH; j++) {

      loadbar(c++,CHECK_IMAGE_WIDTH*CHECK_IMAGE_HEIGHT);

      long_dbl_vec perspective(3, std::vector<long double>{500,(long double)j,(long double)i});
      perspective = prod(rotation,perspective);
      std::map<double,surface*> objects_intersected;
      
      for( std::vector<surface*>::iterator it = bob.begin(); it != bob.end(); it++ ){
	double intersQ = (*it)->intersection_test(perspective, ray_directiion);
	if ( intersQ > 0 )
	  objects_intersected[intersQ] = *it;
      }

      if( !objects_intersected.empty() ){
	surface* foreground_ob = objects_intersected.begin()->second;
	double foreground_ob_dist = objects_intersected.begin()->first;
	dbl_vec point_on_surface = perspective + foreground_ob_dist*ray_directiion;
   
	GLubyte_vec* shading = foreground_ob->shader(point_on_surface);

        checkImage[i][j][0] = (GLubyte)std::min(255,shading[0][0] + shading[1][0] + shading[2][0]);
        checkImage[i][j][1] = (GLubyte)std::min(255,shading[0][1] + shading[1][1] + shading[2][1]);
	checkImage[i][j][2] = (GLubyte)std::min(255,shading[0][2] + shading[1][2] + shading[2][2]);
      }
      else{
	checkImage[i][j][0] = 0;
	checkImage[i][j][1] = 0;
	checkImage[i][j][2] = 0;
      }
    }
  }
  for (i = 1; i < CHECK_IMAGE_HEIGHT-1; i++){
    checkImage[i][0][0] = checkImage[i][CHECK_IMAGE_WIDTH-1][0] = 255; 
    checkImage[i][0][1] = checkImage[i][CHECK_IMAGE_WIDTH-1][1] = 0;
    checkImage[i][0][2] = checkImage[i][CHECK_IMAGE_WIDTH-1][2] = 0;
  }
  for (j = 0; j < CHECK_IMAGE_WIDTH; j++){
    checkImage[0][j][0] = checkImage[CHECK_IMAGE_HEIGHT-1][j][0] = 255; 
    checkImage[0][j][1] = checkImage[CHECK_IMAGE_HEIGHT-1][j][1] = 0;
    checkImage[0][j][2] = checkImage[CHECK_IMAGE_HEIGHT-1][j][2] = 0;
  }
  
  
  
}

void init(std::vector<surface*>& bob) {
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glShadeModel(GL_FLAT);
  makeCheckImage(bob);
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
}

void keyPressed (unsigned char key, int x, int y) {  

  if( key == 'a' ){ // If the 'a' key has been pressed  
    rotate_viewing_angle(0,0,10);
    makeCheckImage(surfaces);
    glutPostRedisplay();
  }
  if( key == 'd' ){
    rotate_viewing_angle(0,0,-10);
    makeCheckImage(surfaces);
    glutPostRedisplay();
  }
  if( key == 'w' ){
    rotate_viewing_angle(0,10,0);
    makeCheckImage(surfaces);
    glutPostRedisplay();
  }
  if( key == 's' ){
    rotate_viewing_angle(0,-10,0);
    makeCheckImage(surfaces);
    glutPostRedisplay();
  }

}  

void display() {
  glClear(GL_COLOR_BUFFER_BIT);
  glRasterPos2i(-1,-1);
  glDrawPixels(CHECK_IMAGE_WIDTH, CHECK_IMAGE_HEIGHT, GL_RGB, GL_UNSIGNED_BYTE, checkImage);
  glFlush();
}

int main(int argc, char **argv) {
  
  int_vec center_circ(3, std::vector<int>{0,250,250});	      	
  int_vec push(3, std::vector<int>{100,0,0});
  surface* sphere1 = new sphere((GLubyte[]){0,255,0}, dbl_vec(3, std::vector<double>{100, 250,250}), 50);
  surface* sphere2 = new sphere((GLubyte[]){255,0,0}, dbl_vec(3, std::vector<double>{50,200,200}), 20);
  surface* triangle1 = new triangle((GLubyte[]){128,128,128}, 
				    dbl_vec(3, std::vector<double>{0,500,0}),
				    dbl_vec(3, std::vector<double>{0,0,0}),
				    dbl_vec(3, std::vector<double>{0,0,500}));  
  surface* triangle2 = new triangle((GLubyte[]){128,128,128}, 
				    dbl_vec(3, std::vector<double>{0,500,0}),
				    dbl_vec(3, std::vector<double>{0,0,500}),
				    dbl_vec(3, std::vector<double>{0,500,500}));  
  
  surfaces = {triangle1,triangle2, sphere1, sphere2};
  rotate_viewing_angle(0,0,0);

  // triangle1->test();

  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_RGB);
  glutInitWindowSize(600,600);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  init(surfaces);
  glutKeyboardFunc(keyPressed); // Tell GLUT to use the method "keyPressed" for key presses  
  // glutKeyboardUpFunc(keyUp); // Tell GLUT to use the method "keyUp" for key up events  
  glutMainLoop();
  return 0;
  
}
