#include <GL/glut.h>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/io.hpp>
#include <math.h>
#include <algorithm>
#include <iostream>
#include <vector>
#include <map>
#include <string>
typedef boost::numeric::ublas::vector<int,std::vector<int> > vec;

#define CHECK_IMAGE_WIDTH 500
#define CHECK_IMAGE_HEIGHT 500
#define PHONG_EXP 5
#define K_S 1
#define K_D 1
#define K_A 1
#define ILLUM 1
vec light_src(3, std::vector<int>{1000,500,500});
static GLubyte checkImage[CHECK_IMAGE_WIDTH][CHECK_IMAGE_HEIGHT][3];
vec ray_directiion(3, std::vector<int>{-1,0,0});

class surface{

public:

  virtual double intersection_test(vec, vec) = 0;
  GLubyte* get_color(){
    return color;
  }
  virtual vec unit_normal(vec) = 0;
  virtual double shader(vec) = 0;
  GLubyte color[3];
  
};

class sphere : public surface{ 

public:
  vec center;
  double radius;
  std::string str;

  sphere(GLubyte surface_color[3], vec center, double radius){
    color[0] = surface_color[0];
    color[1] = surface_color[1];
    color[2] = surface_color[2];
    this->center = center;
    this->radius = radius;
  }

  vec unit_normal(vec point){
    vec normal = point - this->center;
    return normal/norm_2(normal);
  }


  double intersection_test(vec ray_start_vec, vec ray_dir_vec){
    // std::cout << "center " << center << std::endl; 
    vec pov_to_center = ray_start_vec - center;
    // std::cout << "pov_to_center " << pov_to_center << std::endl;
    // std::cout << "ray_dir_vec " << ray_dir_vec << std::endl;
    double v_dot_d = inner_prod(pov_to_center, ray_dir_vec);
    // std::cout << "v.d " << v_dot_d << std::endl;
    double vSquared = inner_prod(pov_to_center, pov_to_center);
    // std::cout << "v^2 " << vSquared << std::endl;
    double rSquared = radius*radius;
    double discr = v_dot_d*v_dot_d - (vSquared - rSquared);
    // std::cout << "discr " << discr << std::endl;
    if( discr > 0 ){
      double sqrtdiscr = sqrt(discr);
      double t1 = -(v_dot_d) + sqrtdiscr;
      double t2 = -(v_dot_d) - sqrtdiscr;
      // std::cout << "t1 " << t1 << std::endl;
      // std::cout << "t2 " << t2 << std::endl;
      return std::min(t1,t2);
    }
    else{
      return -1;
    }
    return 0;
    
  }

  double shader(vec point){

    double diffuse_lighting = K_D*ILLUM*std::max(0,inner_prod(unit_normal(point),light_src));
    // static because perspective RAY direction (not perspective pixel itself) is the same globally
    static vec bisector = (light_src + -1*ray_directiion)/norm_2(light_src + -1*ray_directiion);
    double specular_lighting = K_S*ILLUM*pow(std::max(0,inner_prod(unit_normal(point),bisector)),PHONG_EXP); 
    double ambient_lighting = K_A*ILLUM;

    return ambient_lighting + specular_lighting + diffuse_lighting;
  }
};




void makeCheckImage(std::vector<surface*>& bob) {

  int i, j, c;
  
  
 

  for (i = 0; i < CHECK_IMAGE_HEIGHT; i++){
    
    for (j = 0; j < CHECK_IMAGE_WIDTH; j++) {
      vec perspective(3, std::vector<int>{1000,j,i});
      std::map<double,surface*> objects_intersected;
      
      for( std::vector<surface*>::iterator it = bob.begin(); it != bob.end(); it++ ){
	double intersQ = (*it)->intersection_test(perspective, ray_directiion);
	if ( intersQ > 0 )
	  objects_intersected[intersQ] = *it;
	//objects_intersected.insert( std::pair<intersQ, *it> );
      }
      // vec point = perspective + (objects_intersected.begin()->first)*ray_directiion;
      if( !objects_intersected.empty() ){
	surface* foreground_ob = objects_intersected.begin()->second;
	double foreground_ob_dist = objects_intersected.begin()->first;
	vec point_on_surface = perspective + foreground_ob_dist*ray_directiion;
   
	double shading = foreground_ob->shader(point_on_surface);
	checkImage[i][j][0] = shading*foreground_ob->color[0];
	checkImage[i][j][1] = shading*foreground_ob->color[1];
	checkImage[i][j][2] = shading*foreground_ob->color[2];
      }
      else{
	checkImage[i][j][0] = 0;
	checkImage[i][j][1] = 0;
	checkImage[i][j][2] = 0;
      }
    }
  }
  for (i = 1; i < CHECK_IMAGE_HEIGHT-1; i++){
    checkImage[i][0][0] = checkImage[i][CHECK_IMAGE_WIDTH-1][0] = 255; 
    checkImage[i][0][1] = checkImage[i][CHECK_IMAGE_WIDTH-1][1] = 0;
    checkImage[i][0][2] = checkImage[i][CHECK_IMAGE_WIDTH-1][2] = 0;
  }
  for (j = 0; j < CHECK_IMAGE_WIDTH; j++){
    checkImage[0][j][0] = checkImage[CHECK_IMAGE_HEIGHT-1][j][0] = 255; 
    checkImage[0][j][1] = checkImage[CHECK_IMAGE_HEIGHT-1][j][1] = 0;
    checkImage[0][j][2] = checkImage[CHECK_IMAGE_HEIGHT-1][j][2] = 0;
  }
  
  
  
}

void init(std::vector<surface*>& bob) {
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glShadeModel(GL_FLAT);
  makeCheckImage(bob);
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
}

void display() {
  glClear(GL_COLOR_BUFFER_BIT);
  glRasterPos2i(-1,-1);
  glDrawPixels(CHECK_IMAGE_WIDTH, CHECK_IMAGE_HEIGHT, GL_RGB, GL_UNSIGNED_BYTE, checkImage);
  glFlush();
}

// void reshape(int w, int h) {
//   gluOrtho2D(-10.0f, 10.0f, -10.0f, 10.0f);
//   glViewport(0, 0, w, h);
// }

int main(int argc, char **argv) {
  // std::cout << *(int[]){1,1,1};
  //std::cout << (std::vector<double>{1,2,3,4})[2];
  
  vec center_circ(3, std::vector<int>{0,250,250});	      	
  
  GLubyte bob[3] = {124,252,0};
  surface* sphere1 = new sphere((GLubyte[]){255,255,255}, vec(3, std::vector<int>{0, 250,250}), 100);
  surface* sphere2 = new sphere(bob, vec(3, std::vector<int>{10,100, 50}), 100);
  std::vector<surface*> surfaces = {sphere1, sphere2};
  // std::cout << "persp - cent " << perspective - center_circ << std::endl;
  // std::cout << sphere1->intersection_test(perspective, ray_directiion) << std::endl;
 
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_RGB);
  glutInitWindowSize(600,600);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  // glutReshapeFunc(reshape);	
  init(surfaces);
  glutMainLoop();
 
  return 0;
  
}
