#include <GL/glut.h>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/io.hpp>
#include <math.h>
#include <algorithm>
#include <iostream>
#include <vector>
typedef boost::numeric::ublas::vector<double,std::vector<double> > vec;

#define CHECK_IMAGE_WIDTH 256
#define CHECK_IMAGE_HEIGHT 256
static GLubyte checkImage[CHECK_IMAGE_WIDTH][CHECK_IMAGE_HEIGHT][3];

class surface{

public:

  virtual double intersection_test(vec, vec) = 0;
  GLubyte get_color(){
    return color;
  }


  GLubyte color;
    
};

class sphere : public surface{ 

public:
  vec center;
  double radius;

  sphere(GLubyte surface_color, vec center, double radius){
    color = surface_color;
    center = center;
    radius = radius;
  }
  double intersection_test(vec ray_start_vec, vec ray_dir_vec){
    vec pov_to_center = ray_start_vec - center;
    std::cout << "pov_to_center " << pov_to_center << std::endl;
    std::cout << "ray_dir_vec " << ray_dir_vec << std::endl;
    double v_dot_d = inner_prod(pov_to_center, ray_start_vec);
    double vSquared = inner_prod(pov_to_center, pov_to_center);
    double rSquared = radius*radius;
    double discr = v_dot_d*v_dot_d - (vSquared - rSquared);
    std::cout << "discr " << discr << std::endl;
    if( discr > 0 ){
      double sqrtdiscr = sqrt(discr);
      double t1 = -(v_dot_d) + sqrtdiscr;
      double t2 = -(v_dot_d) - sqrtdiscr;
      std::cout << "t1" << t1 << std::endl;
      std::cout << "t2" << t2 << std::endl;
      return std::min(t1,t2);
    }
    else{
      return -1;
    }
    
    
  }
};


void makeCheckImage(void) {

  int i, j, c;

  for (i = 0; i < CHECK_IMAGE_HEIGHT; i++)

    for (j = 0; j < CHECK_IMAGE_WIDTH; j++) {

      checkImage[i][j][0] = (GLubyte) 124;
      checkImage[i][j][1] = (GLubyte) i == j ? 0 : 252;
      checkImage[i][j][2] = (GLubyte) 0;

    }

}

void init() {
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glShadeModel(GL_FLAT);
  makeCheckImage();
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
}

void display() {
  glClear(GL_COLOR_BUFFER_BIT);
  glRasterPos2i(0, 0);
  glDrawPixels(CHECK_IMAGE_WIDTH, CHECK_IMAGE_HEIGHT, GL_RGB, GL_UNSIGNED_BYTE, checkImage);
  glFlush();
}

// void reshape(int w, int h) {
//   gluOrtho2D(-10.0f, 10.0f, -10.0f, 10.0f);
//   glViewport(0, 0, w, h);
// }

int main(int argc, char **argv) {
  // std::cout << *(int[]){1,1,1};
  //vec center(3, a);
  //vec ray(3, b);
  std::vector<double> v = {1,2,3,4};
  //std::cout << std::vector<double>{1,2,3,4};
  //std::cout << (std::vector<double>{1,2,3,4})[2];
  vec perspective(3, std::vector<double>{1000.,0.,0.});
  vec ray_directiion(3, std::vector<double>{-1.,0.,0.});
  vec center_circ(3, std::vector<double>{0.,0.,0.});	      	
  surface* sphere1 = new sphere((GLubyte) 124, center_circ, 100);
  // std::cout << sphere1->intersection_test(center, ray);
  /*
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_RGB);
  glutInitWindowSize(512,512);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  // glutReshapeFunc(reshape);	
  init();
  glutMainLoop();
  */
  return 0;
  
}
